<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Grand Luxury Interactive Christmas Tree (R3F Single HTML)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Tailwindï¼šä»… UI -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body, #root { margin:0; width:100%; height:100%; background:#05080f; overflow:hidden; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
<div id="root"></div>

<!-- MediaPipe Hands -->
<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

<script type="module">
import React, { useRef, useState, useMemo, useEffect } from "https://esm.sh/react@19";
import ReactDOM from "https://esm.sh/react-dom@19/client";
import { Canvas, useFrame, useThree } from "https://esm.sh/@react-three/fiber";
import { Environment } from "https://esm.sh/@react-three/drei";
import { EffectComposer, Bloom } from "https://esm.sh/@react-three/postprocessing";
import * as THREE from "https://esm.sh/three";

/* =========================================================
   0) å°å·¥å…·ï¼šå¹³æ»‘/å¤¹å–/è¿Ÿæ»
========================================================= */
const clamp01 = (v) => Math.max(0, Math.min(1, v));
const lerp = (a,b,t) => a + (b-a)*t;
// æŒ‡æ•°å¹³æ»‘ï¼ˆæ›´ä¸æ»‘ï¼Œå¸§ç‡æ— å…³ï¼‰
const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
// è¿Ÿæ»å¼€å…³ï¼šé˜²æŠ–ï¼ˆä¸Šé˜ˆå€¼å¼€ï¼Œä¸‹é˜ˆå€¼å…³ï¼‰
const hysteresis = (value, onTh, offTh, currentBool) => {
  if (!currentBool && value > onTh) return true;
  if (currentBool && value < offTh) return false;
  return currentBool;
};

/* =========================================================
   1) é¡¹ç›®è®¾å®šï¼šçŠ¶æ€æœº + é…è‰²
========================================================= */
const MODE = { FORMED: 0, CHAOS: 1 };
const COLORS = {
  bg: "#05080f",
  emerald: new THREE.Color("#0a3a2c"),
  gold: new THREE.Color("#ffd27d"),
  white: new THREE.Color("#ffffff"),
  mint: new THREE.Color("#b8fff0"),
};

/* =========================================================
   2) èµ„æºï¼šè‡ªåŠ¨è¯»å– GitHub Pages çš„ assets/ å›¾ç‰‡
   - åŸç†ï¼šGitHub API åˆ—ç›®å½• -> ./assets/xxx åŠ è½½çº¹ç†
========================================================= */
function inferGithubRepo() {
  const host = location.hostname;
  const owner = host.endsWith(".github.io") ? host.replace(".github.io","") : "probiozzp";
  const seg = location.pathname.split("/").filter(Boolean);
  const repo = seg.length ? seg[0] : "christmas-tree";
  return { owner, repo };
}

async function listAssetsImages() {
  const { owner, repo } = inferGithubRepo();
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/assets`;
  const exts = [".png",".jpg",".jpeg",".webp",".gif"];
  const res = await fetch(api, { cache: "no-store" });
  if (!res.ok) return [];
  const items = await res.json();
  return items
    .filter(it => it.type === "file" && exts.some(ext => it.name.toLowerCase().endsWith(ext)))
    .map(it => it.name);
}

/* =========================================================
   3) é’ˆå¶ç³»ç»Ÿï¼šTHREE.Points + ShaderMaterialï¼ˆå¥¢åç»¿é‡‘ + é‡‘ç²‰é—ªçƒï¼‰
========================================================= */
function Foliage({ mixRef }) {
  const COUNT = 8500;
  const H = 6.5, R = 3.3;

  const geom = useMemo(() => {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT * 3);
    const target = new Float32Array(COUNT * 3);
    const chaos = new Float32Array(COUNT * 3);
    const seed = new Float32Array(COUNT);
    const spark = new Float32Array(COUNT);

    for (let i=0;i<COUNT;i++){
      // targetï¼šåœ†é”¥
      const y = Math.random() * H;
      const radius = (1 - y/H) * R;
      const a = Math.random() * Math.PI*2;
      target.set([Math.cos(a)*radius, y, Math.sin(a)*radius], i*3);

      // chaosï¼šçƒç©ºé—´
      const rr = 9 + Math.random()*12;
      chaos.set([(Math.random()-0.5)*rr, (Math.random()-0.5)*rr*0.7 + 2.5, (Math.random()-0.5)*rr], i*3);

      pos.set([0,0,0], i*3);
      seed[i] = Math.random();
      spark[i] = Math.random();
    }
    g.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    g.setAttribute("aTarget", new THREE.BufferAttribute(target, 3));
    g.setAttribute("aChaos", new THREE.BufferAttribute(chaos, 3));
    g.setAttribute("aSeed", new THREE.BufferAttribute(seed, 1));
    g.setAttribute("aSpark", new THREE.BufferAttribute(spark, 1));
    return g;
  }, []);

  const mat = useMemo(() => new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uMix: { value: 0 },
      uEmerald: { value: COLORS.emerald },
      uGold: { value: COLORS.gold },
      uWhite: { value: COLORS.white },
    },
    vertexShader: `
      attribute vec3 aTarget;
      attribute vec3 aChaos;
      attribute float aSeed;
      attribute float aSpark;

      uniform float uTime;
      uniform float uMix;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      float hash(float n){ return fract(sin(n)*43758.5453123); }

      void main(){
        vec3 p = mix(aTarget, aChaos, uMix);

        float n = hash(aSeed*17.0);
        // æ›´è‡ªç„¶çš„æµ®åŠ¨ï¼ˆå¤šé¢‘ï¼‰
        p.y += sin(uTime*1.2 + aSeed*6.2831) * 0.03 * (0.25 + 0.75*n);
        p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
        p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;
        p.x += sin(uTime*2.1 + aSeed*12.0) * 0.004;
        p.z += cos(uTime*2.1 + aSeed*12.0) * 0.004;

        // é¡¶éƒ¨æ›´äº®
        vGlow = smoothstep(2.0, 6.8, p.y);

        // é‡‘ç²‰é—ªçƒ
        float tw = sin(uTime*3.2 + aSpark*40.0) * 0.5 + 0.5;
        vSpark = smoothstep(0.86, 1.0, tw) * (0.25 + 0.75*vGlow);

        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mv;

        float size = mix(7.0, 16.0, vGlow);
        size += vSpark * 7.0;
        size *= (0.85 + n*0.4);
        gl_PointSize = size * (1.0 / -mv.z);

        vAlpha = clamp(1.0 - (-mv.z / 45.0), 0.20, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      uniform vec3 uEmerald;
      uniform vec3 uGold;
      uniform vec3 uWhite;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);

        float core = smoothstep(0.28, 0.0, d);
        float halo = smoothstep(0.60, 0.15, d);

        vec3 base = mix(uEmerald, uGold, vGlow*0.95);
        vec3 sparkCol = mix(uGold, uWhite, 0.65);
        vec3 col = base + sparkCol * vSpark * (0.35 + core*0.8);

        float a = halo * vAlpha;
        gl_FragColor = vec4(col, a);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  }), []);

  useFrame((_, dt) => {
    mat.uniforms.uTime.value += dt;
    mat.uniforms.uMix.value = mixRef.current;
  });

  return <points geometry={geom} material={mat} />;
}

/* =========================================================
   4) è£…é¥°ç³»ç»Ÿï¼šInstancedMeshï¼ˆé‡/è½»/æè½»çš„æ¨åŠ›æƒé‡ï¼‰
   - ç¤¼ç‰©ç›’ï¼ˆé‡ï¼‰ -> å›å½’æ›´æ…¢ï¼Œæƒ¯æ€§å¤§
   - å½©çƒï¼ˆè½»ï¼‰   -> å›å½’æ›´å¿«
   - ç‚¹ç¼€ç¯ï¼ˆæè½»ï¼‰-> å›å½’æœ€å¿« + é—ªçƒ
========================================================= */
function Ornaments({ mixRef }) {
  const giftRef = useRef();
  const ballRef = useRef();
  const lightRef = useRef();

  const dummy = useMemo(() => new THREE.Object3D(), []);

  const H = 6.5, R = 3.3;

  const makeTargetOnTree = () => {
    const y = Math.random() * (H*0.92) + 0.2;
    const r = (1 - y/H) * R + 0.4;
    const a = Math.random() * Math.PI*2;
    return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
  };
  const makeChaos = () => new THREE.Vector3((Math.random()-0.5)*16, (Math.random()-0.5)*12 + 2, (Math.random()-0.5)*16);

  const data = useMemo(() => {
    const mk = (count, weightMin, weightMax) =>
      new Array(count).fill(0).map(()=>({
        target: makeTargetOnTree(),
        chaos: makeChaos(),
        seed: Math.random(),
        w: weightMin + Math.random()*(weightMax-weightMin)
      }));
    return {
      gifts: mk(55, 0.35, 0.55),  // é‡
      balls: mk(80, 0.65, 0.85),  // è½»
      lights: mk(120, 0.85, 1.0), // æè½»
    };
  }, []);

  useFrame((_, dt) => {
    const mix = mixRef.current;

    // ç¤¼ç‰©ç›’ï¼šå›å½’æ…¢ä¸€ç‚¹ï¼ˆçœ‹èµ·æ¥æ›´â€œé‡â€ï¼‰
    data.gifts.forEach((d,i)=>{
      dummy.position.lerpVectors(d.target, d.chaos, mix);
      dummy.rotation.y = d.seed * Math.PI*2;
      dummy.scale.setScalar(0.18 * d.w);
      dummy.updateMatrix();
      giftRef.current.setMatrixAt(i, dummy.matrix);
    });
    giftRef.current.instanceMatrix.needsUpdate = true;

    // å½©çƒï¼šè½»ä¸€ç‚¹
    data.balls.forEach((d,i)=>{
      const p = new THREE.Vector3().lerpVectors(d.target, d.chaos, mix);
      // è½»å¾®æ¼‚æµ®
      p.y += Math.sin(performance.now()*0.001*1.6 + d.seed*12) * 0.05;
      dummy.position.copy(p);
      dummy.scale.setScalar(0.14 * d.w);
      dummy.updateMatrix();
      ballRef.current.setMatrixAt(i, dummy.matrix);
    });
    ballRef.current.instanceMatrix.needsUpdate = true;

    // ç‚¹ç¼€ç¯ï¼šæè½» + é—ªçƒ
    data.lights.forEach((d,i)=>{
      const p = new THREE.Vector3().lerpVectors(d.target, d.chaos, mix);
      p.y += Math.sin(performance.now()*0.001*2.2 + d.seed*20) * 0.07;
      dummy.position.copy(p);
      const tw = (Math.sin(performance.now()*0.001*4.0 + d.seed*30)*0.5+0.5);
      dummy.scale.setScalar((0.08 + tw*0.06) * d.w);
      dummy.updateMatrix();
      lightRef.current.setMatrixAt(i, dummy.matrix);
    });
    lightRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <>
      {/* ç¤¼ç‰©ç›’ï¼šé‡‘è¾¹ç›’å­ï¼ˆæ›´å¥¢åï¼‰ */}
      <instancedMesh ref={giftRef} args={[null, null, data.gifts.length]}>
        <boxGeometry args={[1,1,1]} />
        <meshStandardMaterial color="#0b5038" metalness={0.6} roughness={0.35} emissive="#1a6b50" emissiveIntensity={0.12}/>
      </instancedMesh>

      {/* å½©çƒï¼šé«˜å…‰é‡‘ */}
      <instancedMesh ref={ballRef} args={[null, null, data.balls.length]}>
        <sphereGeometry args={[1, 22, 22]} />
        <meshStandardMaterial color="#ffd27d" metalness={0.75} roughness={0.22} emissive="#ffd27d" emissiveIntensity={0.15}/>
      </instancedMesh>

      {/* ç‚¹ç¼€ç¯ï¼šç™½é‡‘å‘å…‰ */}
      <instancedMesh ref={lightRef} args={[null, null, data.lights.length]}>
        <sphereGeometry args={[1, 16, 16]} />
        <meshBasicMaterial color="#ffffff" />
      </instancedMesh>
    </>
  );
}

/* =========================================================
   5) å¥¢åä½“ç§¯å…‰ï¼ˆ2ï¼‰ï¼šé‡‘è‰² god-rays + å…‰æŸ±
   - çº¯ Threeï¼šå¤šå±‚ additive sprite/plane å †å ï¼ˆä¸ç”¨é¢å¤–åº“ï¼‰
========================================================= */
function makeRadialTexture() {
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,256,256);
  const g = ctx.createRadialGradient(128,128,0,128,128,128);
  g.addColorStop(0.0, "rgba(255,210,125,0.35)");
  g.addColorStop(0.25,"rgba(255,210,125,0.18)");
  g.addColorStop(0.55,"rgba(255,210,125,0.06)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,256);
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

function VolumetricGold() {
  const tex = useMemo(makeRadialTexture, []);
  const group = useRef();

  useFrame((_, dt) => {
    if (!group.current) return;
    const t = performance.now()*0.001;

    // è½»å¾®å‘¼å¸ + æ—‹è½¬ï¼ˆæ›´â€œç”µå½±â€ï¼‰
    group.current.rotation.y = Math.sin(t*0.12) * 0.15;
    group.current.children.forEach((s, i) => {
      s.material.opacity = 0.18 + (Math.sin(t*1.1 + i*0.7)*0.5+0.5)*0.12;
    });
  });

  return (
    <group ref={group} position={[0, 3.8, -2]}>
      {/* å¤šå±‚è¾‰å…‰é¢ç‰‡å †å ï¼šä¼ªä½“ç§¯ */}
      {new Array(7).fill(0).map((_,i)=>(
        <sprite key={i}
          scale={[18 - i*1.6, 10 - i*0.9, 1]}
          position={[0, 2.6 - i*0.18, -i*0.7]}
        >
          <spriteMaterial
            map={tex}
            transparent
            depthWrite={false}
            blending={THREE.AdditiveBlending}
            color={"#ffd27d"}
            opacity={0.22}
          />
        </sprite>
      ))}
    </group>
  );
}

/* =========================================================
   6) æ˜Ÿé¡¶ starburstï¼ˆ2ï¼‰ï¼šåœ¨ CHAOS æ—¶æ›´æ˜æ˜¾çš„é‡‘è‰²çˆ†è£‚å…‰ç‚¹
========================================================= */
function StarBurst({ mixRef }) {
  const COUNT = 600;
  const geom = useMemo(() => {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const dir = new Float32Array(COUNT*3);
    const seed = new Float32Array(COUNT);
    for (let i=0;i<COUNT;i++){
      pos.set([0,0,0], i*3);
      const v = new THREE.Vector3(
        (Math.random()-0.5),
        (Math.random()-0.5)*0.6 + 0.7,
        (Math.random()-0.5)
      ).normalize().multiplyScalar(1 + Math.random()*3);
      dir.set([v.x, v.y, v.z], i*3);
      seed[i] = Math.random();
    }
    g.setAttribute("position", new THREE.BufferAttribute(pos,3));
    g.setAttribute("aDir", new THREE.BufferAttribute(dir,3));
    g.setAttribute("aSeed", new THREE.BufferAttribute(seed,1));
    return g;
  }, []);

  const mat = useMemo(()=>new THREE.ShaderMaterial({
    uniforms: {
      uTime:{value:0},
      uMix:{value:0}
    },
    vertexShader: `
      attribute vec3 aDir;
      attribute float aSeed;
      uniform float uTime;
      uniform float uMix;
      varying float vA;
      void main(){
        float t = uTime*0.8 + aSeed*10.0;
        float burst = smoothstep(0.0, 1.0, uMix); // chaos æ—¶æ›´å¼º
        float r = (0.3 + sin(t)*0.05) + burst * (1.2 + sin(t*1.8)*0.2);
        vec3 p = aDir * r;
        p.y += 7.2;
        vec4 mv = modelViewMatrix * vec4(p,1.0);
        gl_Position = projectionMatrix * mv;
        float tw = sin(uTime*4.0 + aSeed*30.0)*0.5+0.5;
        vA = (0.05 + tw*0.25) * burst;
        gl_PointSize = (3.0 + tw*5.0) * (1.0 / -mv.z) * 120.0;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying float vA;
      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);
        float a = smoothstep(0.5,0.0,d) * vA;
        gl_FragColor = vec4(1.0, 0.86, 0.55, a);
      }
    `,
    transparent:true,
    depthWrite:false,
    blending:THREE.AdditiveBlending
  }),[]);

  useFrame((_,dt)=>{
    mat.uniforms.uTime.value += dt;
    mat.uniforms.uMix.value = mixRef.current;
  });

  return <points geometry={geom} material={mat} />;
}

/* =========================================================
   7) æ‹ç«‹å¾—ç…§ç‰‡è£…é¥°ï¼ˆ1ï¼‰ï¼šè‡ªåŠ¨è¯»å– assets å¹¶æŒ‚åœ¨æ ‘ä¸Š
   - Dual-Positionï¼štarget(æ ‘) / chaos(æ•£)
   - æ‰‹æŒ‡ hoverï¼šraycast (index tip NDC)
   - pinchï¼šåªç¼©æ”¾ hover çš„é‚£å¼ 
   - pinch>300msï¼šè¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­ï¼Œå…¶ä»–æ·¡ï¼‰
========================================================= */
function makeRoundedAlphaTexture(radiusPx=28){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  function rr(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle="rgba(255,255,255,1)";
  rr(18,18,220,220,radiusPx);
  ctx.fill();
  const tex = new THREE.CanvasTexture(c);
  return tex;
}

function makePaperNoiseTex(){
  const c = document.createElement("canvas");
  c.width = 128; c.height = 128;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(128,128);
  for(let i=0;i<img.data.length;i+=4){
    const n = 200 + Math.floor(Math.random()*55);
    img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=255;
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(4,4);
  return tex;
}

function Polaroids({
  mixRef,
  indexNDCRef,
  pinchRef,
  detailRef,
  onHoverChange
}) {
  const group = useRef();
  const { camera, raycaster, scene } = useThree();

  const [cards, setCards] = useState([]); // {tex, target, chaos, seed, name}
  const loader = useMemo(() => new THREE.TextureLoader(), []);
  const roundAlpha = useMemo(() => makeRoundedAlphaTexture(28), []);
  const paperNoise = useMemo(() => makePaperNoiseTex(), []);

  // åŠ è½½ assets å›¾ç‰‡
  useEffect(() => {
    let alive = true;

    (async ()=>{
      let names = [];
      try { names = await listAssetsImages(); } catch(e){ names = []; }
      if (!alive) return;

      // å¦‚æœæ²¡è¯»åˆ°ï¼ˆä¾‹å¦‚ API é™æµ/ç¦»çº¿ï¼‰ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨è¿™é‡Œå¡ä¸€ä¸ª fallback åˆ—è¡¨
      // names = names.length ? names : ["1.jpg","2.jpg"]; // å¯é€‰

      const H = 6.5, R = 3.3;
      const makeTarget = () => {
        const y = Math.random() * (H*0.82) + 0.8;
        const r = (1 - y/H) * R + 0.9;
        const a = Math.random() * Math.PI*2;
        return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
      };
      const makeChaos = () => new THREE.Vector3((Math.random()-0.5)*16, (Math.random()-0.5)*10 + 2.5, (Math.random()-0.5)*16);

      // é€ä¸ªåŠ è½½çº¹ç†
      const tasks = names.map(name => new Promise((resolve)=>{
        loader.load(`./assets/${encodeURIComponent(name)}`, (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          resolve({
            name,
            tex,
            target: makeTarget(),
            chaos: makeChaos(),
            seed: Math.random()
          });
        }, undefined, ()=>resolve(null));
      }));

      const result = (await Promise.all(tasks)).filter(Boolean);
      if (!alive) return;
      setCards(result);
    })();

    return ()=>{ alive=false; };
  }, []);

  const hoveredIndexRef = useRef(-1);

  useFrame((_, dt) => {
    if (!group.current) return;

    // 1) hoverï¼šç”¨ index tip NDC åš raycast
    const ndc = indexNDCRef.current;
    let hoverIdx = -1;

    if (ndc && cards.length) {
      raycaster.setFromCamera(ndc, camera);
      const intersects = raycaster.intersectObjects(group.current.children, true);
      if (intersects.length) {
        // æˆ‘ä»¬æŠŠæ¯å¼ å¡çš„ root group ä¸Šæ‰“ userData.index
        const obj = intersects[0].object;
        let p = obj;
        while (p && p.parent && p.parent !== group.current) p = p.parent;
        hoverIdx = p?.userData?.index ?? -1;
      }
    }

    if (hoveredIndexRef.current !== hoverIdx) {
      hoveredIndexRef.current = hoverIdx;
      onHoverChange?.(hoverIdx);
    }

    // 2) æ›´æ–°æ¯å¼ æ‹ç«‹å¾—ï¼šDual-position lerp + æ‘†åŠ¨ + pinch scale + detail fade
    const mix = mixRef.current;
    const pinch = pinchRef.current;
    const detail = detailRef.current;

    group.current.children.forEach((root) => {
      const i = root.userData.index;
      const d = cards[i];
      if (!d) return;

      // base position
      const p = new THREE.Vector3().lerpVectors(d.target, d.chaos, mix);

      // æŒ‚ç€çš„æ‘†åŠ¨ï¼ˆæ›´çœŸå®ï¼‰
      const t = performance.now()*0.001;
      const sway = Math.sin(t*0.9 + d.seed*10) * 0.10;
      const tilt = Math.cos(t*0.7 + d.seed*10) * 0.07;

      const isHover = (i === hoveredIndexRef.current);

      if (detail && isHover) {
        // è¯¦æƒ…æ¨¡å¼ï¼šå±…ä¸­é å‰
        root.position.lerp(new THREE.Vector3(0, 3.9, 6.1), 0.10);
        root.rotation.x = damp(root.rotation.x, 0, 10, dt);
        root.rotation.y = damp(root.rotation.y, 0, 10, dt);
        root.rotation.z = damp(root.rotation.z, 0, 10, dt);
      } else {
        root.position.lerp(p, 0.22);
        root.lookAt(0, root.position.y, 0);
        root.rotateZ(sway * 0.6);
        root.rotation.x += tilt*0.05;
        root.rotation.y += sway*0.03;
      }

      // pinchï¼šåªæ”¾å¤§ hover çš„
      const targetS = isHover ? (1 + pinch*1.7) : 1.0;
      root.scale.lerp(new THREE.Vector3(targetS, targetS, targetS), 0.18);

      // è¯¦æƒ…æ¨¡å¼æ·¡å‡ºå…¶ä»–
      const opacity = (detail && !isHover) ? 0.18 : 1.0;

      // æˆ‘ä»¬æŠŠæè´¨å¼•ç”¨æ”¾åœ¨ userData é‡Œ
      const { frameMat, photoMat, bottomMat, glossMat } = root.userData;
      if (frameMat) frameMat.opacity = damp(frameMat.opacity, opacity, 10, dt);
      if (photoMat) photoMat.opacity = damp(photoMat.opacity, opacity, 10, dt);
      if (bottomMat) bottomMat.opacity = damp(bottomMat.opacity, opacity, 10, dt);

      // åå…‰æ¡å¸¦ï¼ˆhover æ›´æ˜æ˜¾ï¼‰
      if (glossMat) {
        const gl = (Math.sin(t*1.7 + d.seed*10)*0.5+0.5);
        const go = (isHover ? 0.22 : 0.08) * gl;
        glossMat.opacity = damp(glossMat.opacity, go, 10, dt);
      }
    });
  });

  // æ¯å¼ æ‹ç«‹å¾—ï¼šç™½ç›¸çº¸ + ç…§ç‰‡ + åº•éƒ¨ç•™ç™½ + åå…‰ + å¤¹å­ + æŒ‚ç»³ + hitProxy
  const renderCard = (d, i) => {
    const cardW=1.12, cardH=1.38, photoW=0.96, photoH=0.80, bottomH=0.30;

    const frameMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#ffffff"),
      roughness: 0.42,
      metalness: 0.05,
      roughnessMap: paperNoise,
      alphaMap: roundAlpha,
      transparent: true,
      opacity: 1
    });

    const photoMat = new THREE.MeshStandardMaterial({
      map: d.tex,
      roughness: 0.25,
      metalness: 0.05,
      transparent: true,
      opacity: 1
    });

    const bottomMat = new THREE.MeshStandardMaterial({
      color: "#f5f5f5",
      roughness: 0.75,
      metalness: 0.0,
      roughnessMap: paperNoise,
      transparent: true,
      opacity: 1
    });

    const glossMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    return (
      <group
        key={d.name}
        userData={{ index: i, frameMat, photoMat, bottomMat, glossMat }}
        position={[d.target.x, d.target.y, d.target.z]}
        onPointerOver={()=>{}}
      >
        {/* frame */}
        <mesh material={frameMat}>
          <planeGeometry args={[cardW, cardH]} />
        </mesh>
        {/* photo */}
        <mesh material={photoMat} position={[0, 0.17, 0.002]}>
          <planeGeometry args={[photoW, photoH]} />
        </mesh>
        {/* bottom */}
        <mesh material={bottomMat} position={[0, -0.44, 0.002]}>
          <planeGeometry args={[photoW, bottomH]} />
        </mesh>
        {/* gloss */}
        <mesh material={glossMat} position={[0, 0, 0.003]}>
          <planeGeometry args={[cardW, cardH]} />
        </mesh>
        {/* clip */}
        <mesh position={[0, cardH*0.52, 0.01]}>
          <boxGeometry args={[0.14, 0.11, 0.04]} />
          <meshStandardMaterial color={"#ffd27d"} metalness={0.75} roughness={0.2} />
        </mesh>
        {/* string */}
        <mesh position={[0, cardH*0.52 + 0.35, 0.0]}>
          <cylinderGeometry args={[0.008, 0.008, 0.7, 10]} />
          <meshBasicMaterial color={"#ffffff"} transparent opacity={0.45}/>
        </mesh>
        {/* hit proxyï¼ˆä¸ºäº† hover æ›´å®¹æ˜“å‘½ä¸­ï¼‰ */}
        <mesh position={[0,0,0.004]}>
          <planeGeometry args={[1.25, 1.5]} />
          <meshBasicMaterial transparent opacity={0}/>
        </mesh>
      </group>
    );
  };

  if (!cards.length) return null;
  return <group ref={group}>{cards.map(renderCard)}</group>;
}

/* =========================================================
   8) ä¸»åœºæ™¯ï¼šçŠ¶æ€æœº+åŒåæ ‡ lerp åœ¨ useFrame ä¸­æ¨è¿›
========================================================= */
function Scene({
  modeRef,            // å½“å‰çŠ¶æ€ï¼ˆFORMED/CHAOSï¼‰
  handYawRef,         // æ‰‹å·¦å³æ§åˆ¶è§†è§’
  indexNDCRef, pinchRef, detailRef,
  setHoverIndex
}) {
  const mixRef = useRef(0);

  // æ›´â€œé«˜çº§â€çš„æ‘„åƒæœºè½»å‘¼å¸ + æ‰‹æ§åˆ¶ yawï¼ˆä¸æ»‘ï¼‰
  const { camera, scene } = useThree();
  useFrame((_, dt) => {
    const targetMix = (modeRef.current === MODE.CHAOS) ? 1 : 0;
    mixRef.current = damp(mixRef.current, targetMix, 2.6, dt);

    const t = performance.now()*0.001;
    const baseY = 4 + Math.sin(t*0.6)*0.15;
    camera.position.x = damp(camera.position.x, 0, 2.0, dt);
    camera.position.y = damp(camera.position.y, baseY, 2.0, dt);
    camera.position.z = damp(camera.position.z, 20, 2.0, dt);

    // yawï¼šæ›´ä¸æ»‘
    camera.rotation.y = damp(camera.rotation.y, handYawRef.current, 4.5, dt);
    camera.lookAt(0, 4, 0);
  });

  return (
    <>
      {/* å¥¢åä½“ç§¯é‡‘å…‰ */}
      <VolumetricGold />

      {/* æ ‘ä¸»ä½“ groupï¼šæ…¢æ…¢è‡ªè½¬ï¼ˆå±•ç¤ºæ›´å¥¢åï¼‰ */}
      <group rotation-y={0.0}>
        <Foliage mixRef={mixRef}/>
        <Ornaments mixRef={mixRef}/>
        <StarBurst mixRef={mixRef}/>
        <Polaroids
          mixRef={mixRef}
          indexNDCRef={indexNDCRef}
          pinchRef={pinchRef}
          detailRef={detailRef}
          onHoverChange={(idx)=>setHoverIndex(idx)}
        />
      </group>

      {/* HDRIï¼šLobby */}
      <Environment preset="lobby" />

      {/* åæœŸ Bloomï¼šé‡‘è‰²è¾‰å…‰ */}
      <EffectComposer>
        <Bloom intensity={1.25} threshold={0.80} mipmapBlur />
      </EffectComposer>
    </>
  );
}

/* =========================================================
   9) æ‰‹åŠ¿æ¨¡å—ï¼šMediaPipe Handsï¼ˆæ›´é¡ºæ‰‹çš„åˆ¤å®š+å¹³æ»‘ï¼‰
   - å¼ å¼€æ‰‹ -> CHAOS
   - æ¡æ‹³   -> FORMED
   - æ‰‹å·¦å³ -> æ—‹è½¬è§†è§’
   - æåˆ   -> ç¼©æ”¾ hover æ‹ç«‹å¾—
   - æåˆ>300ms -> è¯¦æƒ…æ¨¡å¼
========================================================= */
function App() {
  const [started, setStarted] = useState(false);
  const [status, setStatus] = useState("æœªå¯åŠ¨ï¼ˆæ ‘å·²å±•ç¤ºï¼Œç‚¹å‡»å¼€å§‹ä½“éªŒå¯ç”¨æ‘„åƒå¤´ï¼‰");
  const [hoverIndex, setHoverIndex] = useState(-1);

  // UI é¢æ¿è§†é¢‘ï¼ˆå¯è§†åŒ–ï¼‰
  const videoRef = useRef(null);
  const canvasRef = useRef(null);

  // æ‰‹åŠ¿ç»“æœï¼ˆRefï¼šé¿å…é¢‘ç¹ setState æŠ–åŠ¨ï¼‰
  const modeRef = useRef(MODE.FORMED);
  const modeOpenRef = useRef(false); // ç”¨ hysteresis åšå¼€æŒçŠ¶æ€
  const handYawRef = useRef(0);

  const indexNDCRef = useRef(null);
  const pinchRef = useRef(0);
  const detailRef = useRef(false);

  // å¹³æ»‘ç¼“å­˜
  const smoothHandX = useRef(0);
  const smoothPinch = useRef(0);

  // detail è®¡æ—¶
  const pinchHoldStart = useRef(0);

  useEffect(() => {
    if (!started) return;

    let stream = null;
    let hands = null;
    let rafId = null;

    const video = videoRef.current;
    const overlay = canvasRef.current;
    const ctx = overlay?.getContext("2d");

    const resizeOverlay = () => {
      if (!overlay || !video) return;
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;
      const dpr = devicePixelRatio || 1;
      if (overlay.width !== Math.floor(w*dpr) || overlay.height !== Math.floor(h*dpr)) {
        overlay.width = Math.floor(w*dpr);
        overlay.height = Math.floor(h*dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    };

    const drawLandmarks = (lm) => {
      if (!ctx || !overlay) return;
      resizeOverlay();
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!lm) return;

      ctx.fillStyle = "rgba(255,210,125,0.95)";
      for (const p of lm){
        ctx.beginPath();
        ctx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;
      const edges = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [0,9],[9,10],[10,11],[11,12],
        [0,13],[13,14],[14,15],[15,16],
        [0,17],[17,18],[18,19],[19,20]
      ];
      for (const [a,b] of edges){
        const A = lm[a], B = lm[b];
        ctx.beginPath();
        ctx.moveTo(A.x*w, A.y*h);
        ctx.lineTo(B.x*w, B.y*h);
        ctx.stroke();
      }
    };

    const compute = (lm) => {
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const palm = lm[0];

      // pinchï¼šthumb-index è·ç¦» -> 0..1
      const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
      let pinch = (PINCH_MAX - d) / (PINCH_MAX - PINCH_MIN);
      pinch = clamp01(pinch);

      // handXï¼šç”¨ indexTip æ¨ªå‘
      const handX = (indexTip.x - 0.5) * 2; // [-1,1]

      // open/fistï¼šç”¨å››æŒ‡å°–åˆ°æŒå¿ƒçš„è·ç¦»å’Œï¼ˆæ›´ç¨³ï¼‰
      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const openScore = tips.reduce((acc, p) => acc + Math.hypot(p.x - palm.x, p.y - palm.y), 0);

      return { pinch, handX, openScore, indexTip };
    };

    (async () => {
      try {
        setStatus("è¯·æ±‚æ‘„åƒå¤´æƒé™â€¦è¯·å…è®¸");
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        hands = new Hands({ locateFile: f => `https://unpkg.com/@mediapipe/hands/${f}` });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6,
          selfieMode: true
        });

        let lastSeen = performance.now();

        hands.onResults((r) => {
          const lm = r?.multiHandLandmarks?.[0];
          if (!lm) {
            drawLandmarks(null);

            // è¶…æ—¶æ— æ‰‹ -> å›åˆ° FORMED
            if (performance.now() - lastSeen > 1200) {
              modeRef.current = MODE.FORMED;
              handYawRef.current = 0;
              pinchRef.current = 0;
              indexNDCRef.current = null;
              detailRef.current = false;
              pinchHoldStart.current = 0;
            }
            return;
          }

          lastSeen = performance.now();
          drawLandmarks(lm);

          const g = compute(lm);

          // æ›´ä¸æ»‘ï¼šEMA å¹³æ»‘
          const alpha = 0.18;
          smoothHandX.current = smoothHandX.current + (g.handX - smoothHandX.current) * alpha;
          smoothPinch.current = smoothPinch.current + (g.pinch - smoothPinch.current) * alpha;

          // yawï¼šé™åˆ¶èŒƒå›´ + å¹³æ»‘
          handYawRef.current = THREE.MathUtils.clamp(smoothHandX.current * 0.55, -0.95, 0.95);

          // pinch
          pinchRef.current = smoothPinch.current;

          // index tip NDC -> raycast å…‰æ ‡
          indexNDCRef.current = { x: g.indexTip.x*2 - 1, y: -(g.indexTip.y*2 - 1) };

          // å¼€æŒ/æ¡æ‹³ï¼šè¿Ÿæ»é˜ˆå€¼ï¼ˆä¸æŠ–ï¼‰
          // openScore å¤§ï¼šæ›´å¼ å¼€ï¼›å°ï¼šæ›´æ¡
          modeOpenRef.current = hysteresis(g.openScore, 0.60, 0.44, modeOpenRef.current);
          modeRef.current = modeOpenRef.current ? MODE.CHAOS : MODE.FORMED;

          // detailï¼špinch>0.82 ä¸”æœ‰ hover æ‰å…è®¸
          const canDetail = (pinchRef.current > 0.82) && (hoverIndex >= 0);
          if (canDetail) {
            if (!pinchHoldStart.current) pinchHoldStart.current = performance.now();
            if (performance.now() - pinchHoldStart.current > 300) detailRef.current = true;
          } else {
            pinchHoldStart.current = 0;
            detailRef.current = false;
          }
        });

        // pumpï¼šæŒç»­å–‚å¸§
        const pump = async () => {
          if (!hands || !video) return;
          if (video.readyState >= 2) {
            try { await hands.send({ image: video }); } catch(e) {}
          }
          rafId = requestAnimationFrame(pump);
        };
        rafId = requestAnimationFrame(pump);

        setStatus("æ‘„åƒå¤´å·²å¼€å¯ âœ… æ‰‹åŠ¿å¯ç”¨ï¼ˆå¼€æŒæ•£å¼€ / æ¡æ‹³èšåˆ / æåˆæ”¾å¤§æ‹ç«‹å¾—ï¼‰");
      } catch(e) {
        setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ âŒ");
        console.error(e);
        alert(
          "æ‘„åƒå¤´æ— æ³•å¯åŠ¨ã€‚\n\n" +
          "å¸¸è§åŸå› ï¼š\n" +
          "1) ç½‘ç«™æ‘„åƒå¤´æƒé™è¢«ä½ è®¾ä¸ºé˜»æ­¢ï¼ˆChrome ä¸ä¼šå†å¼¹çª—ï¼‰\n" +
          "2) ç³»ç»Ÿè®¾ç½®é‡Œæ²¡å…è®¸æµè§ˆå™¨æ‘„åƒå¤´\n" +
          "3) æ‘„åƒå¤´è¢«å…¶ä»–åº”ç”¨å ç”¨\n\n" +
          "è§£å†³ï¼šåœ°å€æ å·¦ä¾§å°é” -> Camera å…è®¸ -> åˆ·æ–°"
        );
      }
    })();

    return () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (hands && hands.close) hands.close();
      if (stream) stream.getTracks().forEach(t => t.stop());
    };
  }, [started, hoverIndex]);

  return (
    <div className="w-full h-full relative">
      {/* UI */}
      <div className="absolute left-3 top-3 z-20 text-white bg-black/30 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl px-4 py-3 max-w-[760px]">
        <div className="font-semibold">Grand Luxury Interactive Christmas Treeï¼ˆR3F å•æ–‡ä»¶Â·å…¨å¼ºåŒ–ï¼‰</div>
        <div className="text-xs opacity-85 mt-1">
          æ·±ç¥–æ¯ç»¿ + é«˜å…‰é‡‘ + ç”µå½±è¾‰å…‰ï¼ˆBloomï¼‰ + é‡‘è‰²ä½“ç§¯å…‰ + æ˜Ÿçˆ† + æ‹ç«‹å¾—ç…§ç‰‡è£…é¥°ï¼ˆassets è‡ªåŠ¨è¯»å–ï¼‰
        </div>
        <div className="flex gap-2 mt-3 flex-wrap">
          <button
            className="px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15 text-sm"
            onClick={() => setStarted(true)}
            disabled={started}
            title="å¼€å§‹ä½“éªŒä¼šè¯·æ±‚æ‘„åƒå¤´æƒé™"
          >
            â–¶ å¼€å§‹ä½“éªŒï¼ˆå¼€å¯æ‘„åƒå¤´ï¼‰
          </button>
          <div className="text-xs opacity-80 flex items-center">
            çŠ¶æ€ï¼š{status}
          </div>
        </div>

        <div className="text-xs opacity-80 mt-2 whitespace-pre-line">
{`æ‰‹åŠ¿ï¼š
âœ‹ å¼ å¼€æ‰‹æŒï¼šCHAOSï¼ˆunleashï¼‰
âœŠ æ¡æ‹³ï¼šFORMEDï¼ˆå›å½’åœ£è¯æ ‘ï¼‰
ğŸ‘‰ æ‰‹å·¦å³ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
ğŸ¤ æåˆï¼šæ”¾å¤§å½“å‰æŒ‡å‘çš„æ‹ç«‹å¾—
ğŸ¤ æåˆ>300msï¼šè¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œå…¶å®ƒæ·¡å‡ºï¼‰`}
        </div>

        <div className="text-xs opacity-75 mt-2">
          hoverIndexï¼š{hoverIndex} ï½œ detailï¼š{String(detailRef.current)} ï½œ pinchï¼š{pinchRef.current.toFixed(2)}
        </div>
      </div>

      {/* è§†é¢‘é¢æ¿ï¼šè®©ä½ ç¡®è®¤çœŸçš„åœ¨è¯†åˆ« */}
      <div className="absolute right-3 top-3 z-20 w-[360px] rounded-2xl overflow-hidden bg-black/30 backdrop-blur-xl border border-white/10 shadow-2xl">
        <div className="flex justify-between items-center px-3 py-2 text-white/85 text-xs border-b border-white/10">
          <div>Hand Preview</div>
          <div className="font-mono opacity-80">{started ? "ON" : "OFF"}</div>
        </div>
        <div className="relative w-full aspect-video bg-black">
          <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover scale-x-[-1]" muted playsInline autoPlay></video>
          <canvas ref={canvasRef} className="absolute inset-0 w-full h-full"></canvas>
        </div>
        <div className="px-3 py-2 text-white/70 text-[11px] border-t border-white/10 whitespace-pre-line">
          {`æŠŠæ‰‹ä¼¸è¿›ç”»é¢ï¼šä½ ä¼šçœ‹åˆ°å…³é”®ç‚¹
å¦‚æœæ²¡æœ‰ç‚¹ï¼šæ£€æŸ¥æƒé™ï¼ˆåœ°å€æ å°é”ï¼‰æˆ–æ¢ ?v=3 å¼ºåˆ¶åˆ·æ–°`}
        </div>
      </div>

      {/* 3D */}
      <Canvas
        camera={{ position:[0,4,20], fov:55 }}
        gl={{ antialias:true, alpha:false }}
        onCreated={({ gl, scene }) => {
          gl.setClearColor(new THREE.Color(COLORS.bg), 1);
          scene.fog = new THREE.Fog(COLORS.bg, 10, 46);
        }}
      >
        {/* å¥¢åç¯å…‰ï¼šé‡‘è‰²ä¸»å…‰ + å†·è‰²è½®å»“ */}
        <ambientLight intensity={0.16} />
        <directionalLight position={[7, 12, 8]} intensity={2.35} color={"#ffd27d"} />
        <directionalLight position={[-10, 10, -12]} intensity={0.5} color={"#9bdcff"} />
        <pointLight position={[0, 4, 10]} intensity={0.25} color={"#4cffc0"} />

        <Scene
          modeRef={modeRef}
          handYawRef={handYawRef}
          indexNDCRef={indexNDCRef}
          pinchRef={pinchRef}
          detailRef={detailRef}
          setHoverIndex={setHoverIndex}
        />
      </Canvas>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
</script>
</body>
</html>
