<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Luxury Interactive Christmas Tree (Vanilla + Three.js + MediaPipe)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#05080f; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial; }
    #app { position:fixed; inset:0; }
    canvas.webgl { position:absolute; inset:0; width:100%; height:100%; display:block; }
    /* 顶部 UI */
    .hud {
      position: absolute; left: 14px; top: 14px; z-index: 10;
      padding: 12px 14px; border-radius: 16px;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92); backdrop-filter: blur(10px);
      max-width: 560px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
    }
    .title { font-weight: 700; letter-spacing: 0.2px; }
    .sub { font-size: 12px; opacity: 0.85; margin-top: 6px; line-height: 1.35; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap:wrap; margin-top: 10px; }
    button {
      appearance:none; border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 14px;
      cursor:pointer; font-weight: 600; font-size: 13px;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .debug { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: 0.85; margin-top: 10px; line-height: 1.35; }

    /* 右上角摄像头面板 */
    .panel {
      position:absolute; right: 14px; top: 14px; z-index:10;
      width: 360px; border-radius: 16px; overflow:hidden;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.9);
    }
    .panelHead { display:flex; justify-content:space-between; align-items:center; padding: 10px 12px; font-size: 12px; border-bottom: 1px solid rgba(255,255,255,0.10); }
    .panelBody { position:relative; width: 100%; aspect-ratio: 16/9; background: #000; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); }
    canvas#overlay { position:absolute; inset:0; width:100%; height:100%; }
    .panelFoot { padding: 10px 12px; font-size: 11px; opacity: 0.78; border-top: 1px solid rgba(255,255,255,0.10); line-height: 1.35; white-space: pre-line; }
  </style>
</head>
<body>
  <div id="app">
    <canvas class="webgl" id="webgl"></canvas>

    <div class="hud">
      <div class="title">Grand Luxury Interactive Christmas Tree</div>
      <div class="sub">
        深祖母绿 + 高光金色 + 梦幻辉光。<br/>
        手势：张开→散开(CHAOS)，握拳→聚合(FORMED)；握拳+手远离→镜头拉远（先快后慢）；张开+手靠近→镜头快速靠近；手倾斜/旋转→镜头环绕。
        <br/>拍立得：食指指尖 hover；捏合缩放；捏合保持 300ms 进入详情模式。
      </div>

      <div class="row">
        <button id="btnStart">▶ 开始体验（开启摄像头）</button>
        <button id="btnReset">↺ 重置视角</button>
        <span id="status" style="font-size:12px; opacity:0.85;">未启动</span>
      </div>

      <div class="debug" id="debug">
        hand: false | mode: FORMED | radius: 20.0 | yaw: 0.00 | roll: 0.00
      </div>
    </div>

    <div class="panel">
      <div class="panelHead">
        <div>Hand Preview</div>
        <div id="camFlag" style="font-family: ui-monospace; opacity:0.8;">OFF</div>
      </div>
      <div class="panelBody">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="panelFoot">
如果没弹权限：地址栏小锁 → Camera → Allow → 刷新（加 ?v=数字）
注意：必须 https 或 localhost 才能稳定访问摄像头
      </div>
    </div>
  </div>

  <!-- ✅ MediaPipe Hands：按你要求用常规 <script> 引入，得到全局 Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <!-- Three.js 用现代 module（更稳、更接近“modern threejs”） -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /*************************************************************
     * 0) 小工具：平滑、clamp、ease
     *************************************************************/
    const clamp01 = (v) => Math.max(0, Math.min(1, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    // 指数阻尼（比直接 lerp 更“丝滑稳定”）
    const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
    // 先快后慢（ease-out）
    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

    /*************************************************************
     * 1) DOM
     *************************************************************/
    const canvas = document.getElementById("webgl");
    const btnStart = document.getElementById("btnStart");
    const btnReset = document.getElementById("btnReset");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const camFlagEl = document.getElementById("camFlag");

    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const octx = overlay.getContext("2d");

    /*************************************************************
     * 2) Three.js：scene / camera / renderer
     *************************************************************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#05080f");
    scene.fog = new THREE.Fog("#05080f", 10, 55);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // 摄像机：以球坐标围绕树中心 orbit（我们不使用 OrbitControls，完全手势驱动）
    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
    const treeCenter = new THREE.Vector3(0, 4, 0);

    // 目标控制量（由手势驱动）
    const cameraState = {
      radius: 20,        // 当前距离
      targetRadius: 20,  // 目标距离
      yaw: 0,            // 水平旋转
      targetYaw: 0,
      pitch: 0.08,       // 轻微俯视
      targetPitch: 0.08,
      roll: 0,           // 视觉上略参与（其实通过 yaw/pitch 体现）
      targetRoll: 0,
    };

    function applyCamera(dt) {
      // 平滑跟随
      cameraState.radius = damp(cameraState.radius, cameraState.targetRadius, 5.0, dt);
      cameraState.yaw    = damp(cameraState.yaw,    cameraState.targetYaw,    6.0, dt);
      cameraState.pitch  = damp(cameraState.pitch,  cameraState.targetPitch,  6.0, dt);

      // 球坐标 -> 笛卡尔
      const r = cameraState.radius;
      const yaw = cameraState.yaw;
      const pitch = cameraState.pitch;

      const x = Math.sin(yaw) * Math.cos(pitch) * r;
      const z = Math.cos(yaw) * Math.cos(pitch) * r;
      const y = Math.sin(pitch) * r;

      camera.position.set(x, y + treeCenter.y, z);
      camera.lookAt(treeCenter);
    }

    /*************************************************************
     * 3) 灯光：奢华金色高光 + 冷色补光
     *************************************************************/
    scene.add(new THREE.AmbientLight(0xffffff, 0.14));

    const key = new THREE.DirectionalLight("#ffd27d", 2.6);
    key.position.set(8, 14, 10);
    scene.add(key);

    const fill = new THREE.DirectionalLight("#9bdcff", 0.55);
    fill.position.set(-10, 8, -12);
    scene.add(fill);

    const emeraldGlow = new THREE.PointLight("#4cffc0", 0.25, 80);
    emeraldGlow.position.set(0, 6, 12);
    scene.add(emeraldGlow);

    /*************************************************************
     * 4) 圣诞树核心：Dual-Position System
     *    - TargetPosition：锥形树
     *    - ChaosPosition：散落星云
     *    在动画中插值：pos = lerp(target, chaos, mix)
     *************************************************************/
    const MODE = { FORMED: 0, CHAOS: 1 };
    let mode = MODE.FORMED;

    // mix：0=FORMED, 1=CHAOS
    let mix = 0;
    let targetMix = 0;

    // 树参数
    const TREE_H = 6.6;
    const TREE_R = 3.6;

    // 整体容器（用来轻微呼吸/自转）
    const root = new THREE.Group();
    scene.add(root);

    /*************************************************************
     * 4.1 树表面闪烁粒子（Points）
     *************************************************************/
    const SURFACE_COUNT = 8000;
    const surfaceGeo = new THREE.BufferGeometry();
    const surfacePos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceTarget = new Float32Array(SURFACE_COUNT * 3);
    const surfaceChaos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceSeed = new Float32Array(SURFACE_COUNT);

    function conePoint() {
      // y: [0, H]
      const y = Math.random() * TREE_H;
      const radius = (1 - y / TREE_H) * TREE_R;
      const a = Math.random() * Math.PI * 2;
      const x = Math.cos(a) * radius + (Math.random() - 0.5) * 0.12;
      const z = Math.sin(a) * radius + (Math.random() - 0.5) * 0.12;
      return new THREE.Vector3(x, y, z);
    }
    function chaosPoint() {
      // 星云：更大球体空间
      const rr = 16 + Math.random() * 20;
      return new THREE.Vector3(
        (Math.random() - 0.5) * rr,
        (Math.random() - 0.5) * rr * 0.7 + 3.2,
        (Math.random() - 0.5) * rr
      );
    }

    for (let i = 0; i < SURFACE_COUNT; i++) {
      const t = conePoint();
      const c = chaosPoint();
      surfaceTarget.set([t.x, t.y, t.z], i * 3);
      surfaceChaos.set([c.x, c.y, c.z], i * 3);
      surfacePos.set([t.x, t.y, t.z], i * 3);
      surfaceSeed[i] = Math.random();
    }
    surfaceGeo.setAttribute("position", new THREE.BufferAttribute(surfacePos, 3));
    surfaceGeo.setAttribute("aTarget", new THREE.BufferAttribute(surfaceTarget, 3));
    surfaceGeo.setAttribute("aChaos", new THREE.BufferAttribute(surfaceChaos, 3));
    surfaceGeo.setAttribute("aSeed", new THREE.BufferAttribute(surfaceSeed, 1));

    // Shader：祖母绿->金色渐变 + 闪烁
    const surfaceMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },
        uEmerald: { value: new THREE.Color("#0a3a2c") },
        uGold: { value: new THREE.Color("#ffd27d") },
        uWhite: { value: new THREE.Color("#ffffff") },
      },
      vertexShader: `
        attribute vec3 aTarget;
        attribute vec3 aChaos;
        attribute float aSeed;

        uniform float uTime;
        uniform float uMix;

        varying float vGlow;
        varying float vTw;

        float hash(float n){ return fract(sin(n)*43758.5453123); }

        void main(){
          vec3 p = mix(aTarget, aChaos, uMix);

          // 呼吸漂浮
          float n = hash(aSeed*17.0);
          p.y += sin(uTime*1.25 + aSeed*6.2831) * 0.035 * (0.2 + 0.8*n);
          p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
          p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;

          // 从底到顶：金色更强
          vGlow = smoothstep(1.6, 6.6, p.y);

          // 闪烁
          float tw = sin(uTime*3.1 + aSeed*40.0) * 0.5 + 0.5;
          vTw = smoothstep(0.86, 1.0, tw) * (0.25 + 0.75*vGlow);

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = mix(7.0, 18.0, vGlow);
          size += vTw * 8.0;
          size *= (0.85 + n*0.4);
          gl_PointSize = size * (1.0 / -mv.z);
        }
      `,
      fragmentShader: `
        precision highp float;

        uniform vec3 uEmerald;
        uniform vec3 uGold;
        uniform vec3 uWhite;

        varying float vGlow;
        varying float vTw;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.28, 0.0, d);
          float halo = smoothstep(0.62, 0.15, d);

          vec3 base = mix(uEmerald, uGold, vGlow*0.95);
          vec3 spark = mix(uGold, uWhite, 0.6);
          vec3 col = base + spark * vTw * (0.35 + core*0.9);

          float a = halo;
          gl_FragColor = vec4(col, a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const surfacePoints = new THREE.Points(surfaceGeo, surfaceMat);
    root.add(surfacePoints);

    /*************************************************************
     * 4.2 “挂件”InstancedMesh：彩球/礼盒/小灯（不同权重）
     *************************************************************/
    const ORN_COUNT = 900;
    const ornGroup = new THREE.Group();
    root.add(ornGroup);

    // 三类挂件：球（轻）、盒（重）、小灯（极轻）
    const ballCount = Math.floor(ORN_COUNT * 0.55);
    const boxCount  = Math.floor(ORN_COUNT * 0.25);
    const lampCount = ORN_COUNT - ballCount - boxCount;

    function makeInstanced(geo, mat, count) {
      const im = new THREE.InstancedMesh(geo, mat, count);
      im.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      return im;
    }

    const ballGeo = new THREE.SphereGeometry(0.08, 12, 12);
    const boxGeo  = new THREE.BoxGeometry(0.13, 0.13, 0.13);
    const lampGeo = new THREE.SphereGeometry(0.045, 10, 10);

    const gold = new THREE.Color("#ffd27d");
    const emerald = new THREE.Color("#0a3a2c");

    const ballMat = new THREE.MeshStandardMaterial({ color: gold, metalness: 0.75, roughness: 0.18, emissive: gold, emissiveIntensity: 0.12 });
    const boxMat  = new THREE.MeshStandardMaterial({ color: emerald, metalness: 0.40, roughness: 0.28, emissive: gold, emissiveIntensity: 0.06 });
    const lampMat = new THREE.MeshStandardMaterial({ color: new THREE.Color("#ffffff"), metalness: 0.1, roughness: 0.15, emissive: new THREE.Color("#ffffff"), emissiveIntensity: 0.55 });

    const balls = makeInstanced(ballGeo, ballMat, ballCount);
    const boxes = makeInstanced(boxGeo, boxMat, boxCount);
    const lamps = makeInstanced(lampGeo, lampMat, lampCount);

    ornGroup.add(balls, boxes, lamps);

    // 双坐标 + 物理“推力权重”（重的归位更慢）
    const ornTarget = [];
    const ornChaos = [];
    const ornWeight = []; // 归位阻尼：大=更重更慢

    function randomConeOrn() {
      const y = Math.random() * (TREE_H * 0.85) + 0.6;
      const r = (1 - y / TREE_H) * TREE_R + 0.25;
      const a = Math.random() * Math.PI * 2;
      return new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
    }

    for (let i = 0; i < ORN_COUNT; i++) {
      ornTarget.push(randomConeOrn());
      ornChaos.push(chaosPoint());

      // 分类权重：盒子最重、球中等、灯最轻
      if (i < ballCount) ornWeight.push(1.0);
      else if (i < ballCount + boxCount) ornWeight.push(2.2);
      else ornWeight.push(0.6);
    }

    // 实例矩阵更新（每帧写入）
    const tmpObj = new THREE.Object3D();

    function updateOrnaments(dt, time) {
      const tMix = mix;

      // 轻微波动更“奢华”
      const breathe = (Math.sin(time * 1.2) * 0.5 + 0.5) * 0.06;

      // balls
      for (let i = 0; i < ballCount; i++) {
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.6 + i * 0.03) * 0.02;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.7 + i) * 0.15,
          Math.cos(time * 0.6 + i) * 0.2,
          Math.sin(time * 0.5 + i) * 0.1
        );
        const s = 1.0 + breathe;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        balls.setMatrixAt(i, tmpObj.matrix);
      }
      balls.instanceMatrix.needsUpdate = true;

      // boxes
      for (let j = 0; j < boxCount; j++) {
        const i = ballCount + j;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.1 + i * 0.02) * 0.015;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.3 + i) * 0.25,
          Math.cos(time * 0.35 + i) * 0.35,
          Math.sin(time * 0.28 + i) * 0.2
        );
        const s = 1.0 + breathe * 0.8;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        boxes.setMatrixAt(j, tmpObj.matrix);
      }
      boxes.instanceMatrix.needsUpdate = true;

      // lamps
      for (let k = 0; k < lampCount; k++) {
        const i = ballCount + boxCount + k;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 2.6 + i * 0.05) * 0.03;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(0, 0, 0);
        const tw = (Math.sin(time * 4.5 + i * 0.9) * 0.5 + 0.5);
        const s = 1.0 + tw * 0.6;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        lamps.setMatrixAt(k, tmpObj.matrix);
      }
      lamps.instanceMatrix.needsUpdate = true;
    }

    /*************************************************************
     * 4.3 顶部星星（发光金色）
     *************************************************************/
    const star = new THREE.Group();
    star.position.set(0, TREE_H + 0.55, 0);
    root.add(star);

    // 星星：用两个交叉的四角“伪星”
    const starMat = new THREE.MeshStandardMaterial({
      color: "#ffd27d", metalness: 0.95, roughness: 0.12,
      emissive: "#ffd27d", emissiveIntensity: 0.85
    });

    const starGeo = new THREE.OctahedronGeometry(0.26, 0);
    const starMesh = new THREE.Mesh(starGeo, starMat);
    star.add(starMesh);

    // 外层发光 sprite（模拟 bloom）
    function makeRadialTexture() {
      const c = document.createElement("canvas");
      c.width = 256; c.height = 256;
      const ctx = c.getContext("2d");
      const g = ctx.createRadialGradient(128,128,0,128,128,128);
      g.addColorStop(0.0, "rgba(255,210,125,0.55)");
      g.addColorStop(0.25,"rgba(255,210,125,0.25)");
      g.addColorStop(0.6, "rgba(255,210,125,0.08)");
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,256,256);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const glowTex = makeRadialTexture();
    const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex, color: "#ffd27d", transparent: true, opacity: 0.65,
      blending: THREE.AdditiveBlending, depthWrite: false
    }));
    glowSprite.scale.set(3.2, 3.2, 1);
    star.add(glowSprite);

    /*************************************************************
     * 5) 白色粒子光晕（围绕圣诞树的 halo）
     *************************************************************/
    const HALO_COUNT = 2200;
    const haloGeo = new THREE.BufferGeometry();
    const haloPos = new Float32Array(HALO_COUNT * 3);
    const haloSeed = new Float32Array(HALO_COUNT);

    // 光晕：围绕树的“椭圆环” + 轻微上下飘
    for (let i = 0; i < HALO_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const rad = 5.2 + Math.random() * 2.0;
      const y = 3.8 + (Math.random() - 0.5) * 2.0;
      haloPos.set([Math.cos(a) * rad, y, Math.sin(a) * rad], i * 3);
      haloSeed[i] = Math.random();
    }
    haloGeo.setAttribute("position", new THREE.BufferAttribute(haloPos, 3));
    haloGeo.setAttribute("aSeed", new THREE.BufferAttribute(haloSeed, 1));

    const haloMat = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0 } },
      vertexShader: `
        attribute float aSeed;
        uniform float uTime;
        varying float vA;
        void main(){
          vec3 p = position;

          float t = uTime;
          float wob = sin(t*0.8 + aSeed*6.2831) * 0.15;
          float spin = (t*0.18 + aSeed*6.2831);

          // 环绕旋转
          float cs = cos(spin), sn = sin(spin);
          p.xz = mat2(cs, -sn, sn, cs) * p.xz;

          // 上下漂浮
          p.y += wob;

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = 4.0 + (sin(t*2.2 + aSeed*30.0)*0.5+0.5)*4.0;
          gl_PointSize = size * (1.0 / -mv.z);

          vA = 0.25 + (sin(t*1.6 + aSeed*20.0)*0.5+0.5)*0.35;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float a = smoothstep(0.6, 0.05, d) * vA;
          gl_FragColor = vec4(vec3(1.0), a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const halo = new THREE.Points(haloGeo, haloMat);
    root.add(halo);

    /*************************************************************
     * 6) 拍立得照片挂件（内置图片）
     *    - 默认读取 ./assets/1.jpg..6.jpg
     *    - Raycaster 用食指指尖选中
     *    - pinch 控制选中照片缩放
     *    - pinch hold >300ms 进入详情模式
     *************************************************************/
    const raycaster = new THREE.Raycaster();
    const polaroidGroup = new THREE.Group();
    root.add(polaroidGroup);

    const POLAROIDS = [
      "./assets/1.jpg",
      "./assets/2.jpg",
      "./assets/3.jpg",
      "./assets/4.jpg",
      "./assets/5.jpg",
      "./assets/6.jpg"
    ];

    const textureLoader = new THREE.TextureLoader();

    // 生成拍立得材质（白框 + 底部留白 + 透明高光）
    function makePolaroid(tex) {
      tex.colorSpace = THREE.SRGBColorSpace;

      // 组
      const g = new THREE.Group();

      // 尺寸
      const cardW = 1.18, cardH = 1.48;
      const photoW = 1.02, photoH = 0.86;
      const bottomH = 0.30;

      // 白框
      const frameMat = new THREE.MeshStandardMaterial({
        color: "#ffffff", roughness: 0.42, metalness: 0.05, transparent: true, opacity: 1
      });
      const frame = new THREE.Mesh(new THREE.PlaneGeometry(cardW, cardH), frameMat);
      g.add(frame);

      // 照片
      const photoMat = new THREE.MeshStandardMaterial({
        map: tex, roughness: 0.25, metalness: 0.05, transparent: true, opacity: 1
      });
      const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), photoMat);
      photo.position.set(0, 0.18, 0.002);
      g.add(photo);

      // 底部留白
      const bottomMat = new THREE.MeshStandardMaterial({
        color: "#f5f5f5", roughness: 0.75, metalness: 0.0, transparent: true, opacity: 1
      });
      const bottom = new THREE.Mesh(new THREE.PlaneGeometry(photoW, bottomH), bottomMat);
      bottom.position.set(0, -0.46, 0.002);
      g.add(bottom);

      // 透明 hit-area（方便 Raycaster 命中）
      const hit = new THREE.Mesh(new THREE.PlaneGeometry(cardW * 1.08, cardH * 1.08), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
      hit.position.set(0, 0, 0.004);
      g.add(hit);

      // 小金色挂钩
      const hook = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.11, 0.04), new THREE.MeshStandardMaterial({ color: "#ffd27d", metalness: 0.85, roughness: 0.18 }));
      hook.position.set(0, cardH * 0.52, 0.01);
      g.add(hook);

      // 一根细线
      const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.7, 10), new THREE.MeshBasicMaterial({ color: "#ffffff", transparent: true, opacity: 0.45 }));
      wire.position.set(0, cardH * 0.52 + 0.35, 0.0);
      g.add(wire);

      // 高光（选中时更明显）
      const gloss = new THREE.Sprite(new THREE.SpriteMaterial({
        map: glowTex, color: "#ffffff", transparent: true, opacity: 0.0,
        blending: THREE.AdditiveBlending, depthWrite: false
      }));
      gloss.scale.set(1.8, 2.2, 1);
      gloss.position.set(0.0, 0.05, 0.03);
      g.add(gloss);

      g.userData = { frameMat, photoMat, bottomMat, glossMat: gloss.material, hit };
      return g;
    }

    // 将拍立得挂到树上：使用 target cone positions（像挂件一样）
    const polaroids = [];
    async function loadPolaroids() {
      for (let i = 0; i < POLAROIDS.length; i++) {
        const url = POLAROIDS[i];
        try {
          const tex = await new Promise((resolve, reject) => {
            textureLoader.load(url, resolve, undefined, reject);
          });
          const card = makePolaroid(tex);
          // 分布到树上（尽量靠外表面）
          const y = Math.random() * (TREE_H * 0.8) + 0.9;
          const r = (1 - y / TREE_H) * TREE_R + 1.05;
          const a = Math.random() * Math.PI * 2;
          const target = new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
          const chaos = chaosPoint();

          card.position.copy(target);
          card.lookAt(0, target.y, 0);
          card.rotateZ((Math.random() - 0.5) * 0.5);

          card.userData.index = i;
          card.userData.target = target;
          card.userData.chaos = chaos;
          card.userData.baseScale = 1.0;

          polaroidGroup.add(card);
          polaroids.push(card);
        } catch (e) {
          console.warn("加载图片失败：", url, e);
        }
      }
    }

    /*************************************************************
     * 7) 手势系统：MediaPipe Hands（全局 Hands）
     *************************************************************/
    let started = false;
    let mpHands = null;
    let stream = null;

    // 手势输入状态（每帧更新）
    const handState = {
      hasHand: false,
      // 食指指尖 NDC（用于 raycast hover）
      indexNDC: null,
      // 捏合强度 0..1
      pinch: 0,
      // 是否张开、是否握拳（带迟滞）
      open: false,
      fist: false,
      // 手的“旋转/倾斜”参数：用于控制相机 yaw/roll
      yaw: 0,   // -1..1
      roll: 0,  // -1..1
      // 手距离（用手大小近似）：越大越近
      size: 0,
      // 上次检测到手的时间
      lastSeen: 0,
      // 选中的拍立得 index
      hoverIndex: -1,
      selectedIndex: -1,
      detailMode: false,
      pinchHoldStart: 0
    };

    // 画关键点（仅用于 debug）
    function drawLandmarks(lm) {
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;

      const dpr = Math.min(devicePixelRatio || 1, 2);
      if (overlay.width !== Math.floor(w * dpr) || overlay.height !== Math.floor(h * dpr)) {
        overlay.width = Math.floor(w * dpr);
        overlay.height = Math.floor(h * dpr);
        octx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      octx.clearRect(0, 0, w, h);

      if (!lm) return;

      octx.fillStyle = "rgba(255,210,125,0.95)";
      for (const p of lm) {
        octx.beginPath();
        octx.arc(p.x * w, p.y * h, 4, 0, Math.PI * 2);
        octx.fill();
      }
    }

    // 迟滞开关：防抖（open/fist 更稳）
    function hysteresis(value, onTh, offTh, current) {
      if (!current && value > onTh) return true;
      if (current && value < offTh) return false;
      return current;
    }

    // 从 landmarks 计算手势
    function computeGestures(lm) {
      // landmarks index：
      // 0 wrist
      // 4 thumb tip
      // 8 index tip
      // 5 index mcp
      // 17 pinky mcp
      // 9 middle mcp
      const wrist = lm[0];
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const midMcp = lm[9];
      const indexMcp = lm[5];
      const pinkyMcp = lm[17];

      // 手大小（近似深度）：用包围盒对角线
      let minX=1, minY=1, maxX=0, maxY=0;
      for (const p of lm) {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
      }
      const size = Math.hypot(maxX - minX, maxY - minY); // 0.2~0.6 这种量级

      // pinch：拇指+食指距离越小，pinch 越大
      const dPin = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
      let pinch = (PINCH_MAX - dPin) / (PINCH_MAX - PINCH_MIN);
      pinch = clamp01(pinch);

      // openScore：四个指尖到手腕的距离和（越大越张开）
      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const openScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - wrist.x, p.y - wrist.y), 0);

      // fistScore：指尖到掌心（midMcp）的距离和（越小越像握拳）
      const fistScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - midMcp.x, p.y - midMcp.y), 0);

      // 用迟滞得到 open / fist
      // 注意：阈值经验值，后面可根据你镜头距离调
      handState.open = hysteresis(openScoreRaw, 0.62, 0.50, handState.open);
      handState.fist = hysteresis(1.0 - fistScoreRaw, 0.32, 0.22, handState.fist); // 反向映射

      // “旋转/倾斜”：用掌的横向方向向量估计 roll，用手中心 x 估计 yaw
      // yaw：手中心 x 偏移（镜像修正：视频是镜像，所以这里取负号让左右直觉一致）
      const centerX = (minX + maxX) * 0.5;
      let yaw = -((centerX - 0.5) * 2); // -1..1

      // roll：用 indexMcp->pinkyMcp 的连线角度（横向向量）估计
      const vx = pinkyMcp.x - indexMcp.x;
      const vy = pinkyMcp.y - indexMcp.y;
      const angle = Math.atan2(vy, vx); // -pi..pi
      // 映射到 -1..1（小范围更敏感）
      let roll = THREE.MathUtils.clamp(angle / 1.2, -1, 1);

      // 食指指尖 NDC：用于 raycaster（镜像修正）
      const ndcX = - (indexTip.x * 2 - 1);
      const ndcY = - (indexTip.y * 2 - 1);

      return { pinch, yaw, roll, size, ndcX, ndcY, openScoreRaw, fistScoreRaw };
    }

    async function startMediaPipe() {
      if (started) return;
      started = true;
      btnStart.disabled = true;

      statusEl.textContent = "请求摄像头权限…";
      camFlagEl.textContent = "ON";

      // 1) 摄像头
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();

      // 2) MediaPipe Hands（全局 Hands）
      //    locateFile 用 CDN 路径补齐 wasm/asset
      mpHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      mpHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: true
      });

      // 防止 send 堆积（inFlight）
      let inFlight = false;

      mpHands.onResults((results) => {
        const lm = results?.multiHandLandmarks?.[0];

        if (!lm) {
          drawLandmarks(null);
          handState.hasHand = false;
          return;
        }

        handState.hasHand = true;
        handState.lastSeen = performance.now();

        drawLandmarks(lm);

        const g = computeGestures(lm);

        // 平滑（避免抖）
        const a = 0.18;
        handState.pinch = lerp(handState.pinch, g.pinch, a);
        handState.yaw   = lerp(handState.yaw,   g.yaw,   a);
        handState.roll  = lerp(handState.roll,  g.roll,  a);
        handState.size  = lerp(handState.size,  g.size,  a);

        handState.indexNDC = { x: g.ndcX, y: g.ndcY };

        // 状态机：FORMED / CHAOS
        // - 张开 或 “明显旋转/倾斜” => CHAOS
        // - 握拳 => FORMED
        const rotateTrigger = Math.abs(handState.roll) > 0.55;
        if (handState.fist) mode = MODE.FORMED;
        else if (handState.open || rotateTrigger) mode = MODE.CHAOS;

        // 相机 orbit：yaw/roll 控制旋转（roll 少量参与）
        cameraState.targetYaw = THREE.MathUtils.clamp(handState.yaw * 1.15 + handState.roll * 0.35, -2.2, 2.2);

        // Zoom：用 size 近似 Z（越大越近）
        // - 握拳 + 手远离（size 变小） => 拉远（先快后慢：我们用目标半径跳变 + 强阻尼）
        // - 张开 + 手靠近（size 变大） => 快速靠近
        const sizeNorm = clamp01((handState.size - 0.18) / (0.52 - 0.18)); // 0..1
        if (handState.fist) {
          // 远离：size 小 => radius 大
          const r = lerp(18, 40, 1 - sizeNorm);
          cameraState.targetRadius = r;
        } else if (handState.open) {
          // 靠近：size 大 => radius 小
          const r = lerp(28, 12, sizeNorm);
          cameraState.targetRadius = r;
        } else {
          // 中性状态：慢慢回到默认
          cameraState.targetRadius = 20;
        }

        // 拍立得 pinch：只对选中项缩放 + 详情模式
        const PINCH_DETAIL_ON = 0.72;
        const hovering = (handState.hoverIndex >= 0);

        if (hovering && handState.pinch > PINCH_DETAIL_ON) {
          if (!handState.pinchHoldStart) handState.pinchHoldStart = performance.now();
          if (performance.now() - handState.pinchHoldStart > 300) {
            handState.detailMode = true;
            handState.selectedIndex = handState.hoverIndex;
          }
        } else {
          handState.pinchHoldStart = 0;
          handState.detailMode = false;
        }

        // loop pump 会做 send
        // 这里只更新状态即可
      });

      // 手动 pump（不用 camera_utils）
      const pump = async () => {
        if (!mpHands) return;
        if (video.readyState >= 2 && !inFlight) {
          inFlight = true;
          try { await mpHands.send({ image: video }); } catch(e) {}
          inFlight = false;
        }
        requestAnimationFrame(pump);
      };
      requestAnimationFrame(pump);

      statusEl.textContent = "摄像头已开启 ✅";
    }

    btnStart.addEventListener("click", async () => {
      try {
        await startMediaPipe();
      } catch (e) {
        console.error(e);
        alert("摄像头启动失败。请检查：地址栏小锁→Camera Allow；必须 https 或 localhost；或系统隐私设置。");
        statusEl.textContent = "摄像头启动失败 ❌";
      }
    });

    btnReset.addEventListener("click", () => {
      cameraState.targetYaw = 0;
      cameraState.targetPitch = 0.08;
      cameraState.targetRadius = 20;
    });

    /*************************************************************
     * 8) Raycaster：用食指指尖 hover/选中拍立得
     *************************************************************/
    function updateRaycastHover() {
      if (!handState.hasHand || !handState.indexNDC || polaroids.length === 0) {
        handState.hoverIndex = -1;
        return;
      }

      raycaster.setFromCamera(handState.indexNDC, camera);
      // 只对拍立得组做 intersect
      const hits = raycaster.intersectObjects(polaroidGroup.children, true);

      if (!hits.length) {
        handState.hoverIndex = -1;
        return;
      }

      // 找到其 parent card（我们给 card.userData.index）
      let obj = hits[0].object;
      while (obj && obj.parent && obj.parent !== polaroidGroup) obj = obj.parent;
      const idx = obj?.userData?.index;
      handState.hoverIndex = (typeof idx === "number") ? idx : -1;
    }

    /*************************************************************
     * 9) 树/拍立得：FORMED<->CHAOS 插值 + 详情模式
     *************************************************************/
    function updateSurfacePositions(time) {
      surfaceMat.uniforms.uTime.value = time;
      surfaceMat.uniforms.uMix.value = mix;

      // position attribute 其实可以不改（shader里用 aTarget/aChaos），但我们这里保持简单只在 shader 插值
      // 所以无需写 position buffer
    }

    function updatePolaroids(dt, time) {
      const tMix = mix;

      for (const card of polaroids) {
        const idx = card.userData.index;
        const target = card.userData.target;
        const chaos = card.userData.chaos;

        const isHover = (idx === handState.hoverIndex);
        const isSelected = (idx === handState.selectedIndex) && handState.detailMode;

        // 位置：FORMED/CHAOS 插值
        const p = new THREE.Vector3(
          lerp(target.x, chaos.x, tMix),
          lerp(target.y, chaos.y, tMix),
          lerp(target.z, chaos.z, tMix)
        );

        // 普通状态：挂在树上朝向树干 + 摇摆
        if (!isSelected) {
          card.position.lerp(p, 0.22);
          card.lookAt(0, card.position.y, 0);
          card.rotateZ(Math.sin(time * 0.9 + idx) * 0.06);
        }

        // 详情模式：居中
        if (isSelected) {
          card.position.lerp(new THREE.Vector3(0, 4.2, 6.0), 0.12);
          card.rotation.x = damp(card.rotation.x, 0, 10, dt);
          card.rotation.y = damp(card.rotation.y, 0, 10, dt);
          card.rotation.z = damp(card.rotation.z, 0, 10, dt);
        }

        // pinch 缩放：仅对 hover 生效（详情模式下更大）
        const pinch = handState.pinch;
        const base = isSelected ? 2.1 : 1.0;
        const zoom = isHover ? (1.0 + pinch * 2.0) : 1.0;
        const targetScale = base * zoom;
        card.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.18);

        // 高光/透明：详情模式下其他淡出
        const fadeOthers = handState.detailMode && !isSelected;
        const opacityTarget = fadeOthers ? 0.18 : 1.0;

        const { frameMat, photoMat, bottomMat, glossMat } = card.userData;
        frameMat.opacity  = damp(frameMat.opacity,  opacityTarget, 10, dt);
        photoMat.opacity  = damp(photoMat.opacity,  opacityTarget, 10, dt);
        bottomMat.opacity = damp(bottomMat.opacity, opacityTarget, 10, dt);

        // gloss：hover 更亮
        const gl = (Math.sin(time * 1.7 + idx) * 0.5 + 0.5);
        const glossTarget = (isHover ? 0.22 : 0.06) * gl;
        glossMat.opacity = damp(glossMat.opacity, glossTarget, 10, dt);
      }
    }

    /*************************************************************
     * 10) 无手自动回归
     *************************************************************/
    function noHandFallback(now) {
      if (!handState.hasHand) {
        // 超过 1s 没看到手：回默认
        if (now - handState.lastSeen > 1000) {
          mode = MODE.FORMED;
          cameraState.targetYaw = damp(cameraState.targetYaw, 0, 3.0, 1/60);
          cameraState.targetRadius = damp(cameraState.targetRadius, 20, 3.0, 1/60);
          handState.pinch = damp(handState.pinch, 0, 6.0, 1/60);
          handState.hoverIndex = -1;
          handState.selectedIndex = -1;
          handState.detailMode = false;
        }
      }
    }

    /*************************************************************
     * 11) 主循环
     *************************************************************/
    let lastT = performance.now() * 0.001;

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now() * 0.001;
      const dt = Math.min(0.033, now - lastT);
      lastT = now;

      // mix 平滑切换（CHAOS/FORMED）
      targetMix = (mode === MODE.CHAOS) ? 1 : 0;
      mix = damp(mix, targetMix, 2.6, dt);

      // 树整体：轻微自转 + 呼吸（更炫）
      root.rotation.y += 0.0022;
      root.position.y = Math.sin(now * 0.7) * 0.03;

      // star 动画
      star.rotation.y = now * 0.9;
      glowSprite.material.opacity = 0.55 + (Math.sin(now * 2.0) * 0.5 + 0.5) * 0.22;

      // halo 动画
      haloMat.uniforms.uTime.value = now;

      // 手势 hover 更新（用当前相机、当前指尖）
      updateRaycastHover();

      // 更新拍立得
      updatePolaroids(dt, now);

      // 更新挂件实例
      updateOrnaments(dt, now);

      // 更新表面粒子 shader
      updateSurfacePositions(now);

      // 无手回归
      noHandFallback(performance.now());

      // 相机（握拳拉远“先快后慢”：通过 targetRadius 跳变 + damp 自然产生）
      // 如果你想更“先快后慢”，可把 radius 的 damp lambda 提高到 6~8。
      applyCamera(dt);

      // debug
      debugEl.textContent =
        `hand: ${handState.hasHand} | mode: ${mode === MODE.CHAOS ? "CHAOS" : "FORMED"} | radius: ${cameraState.radius.toFixed(1)} | yaw: ${cameraState.yaw.toFixed(2)} | roll: ${handState.roll.toFixed(2)}\n` +
        `open: ${handState.open} | fist: ${handState.fist} | pinch: ${handState.pinch.toFixed(2)} | size: ${handState.size.toFixed(2)}\n` +
        `hover: ${handState.hoverIndex} | detail: ${handState.detailMode} | selected: ${handState.selectedIndex}`;

      renderer.render(scene, camera);
    }

    /*************************************************************
     * 12) resize
     *************************************************************/
    window.addEventListener("resize", () => {
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
    });

    /*************************************************************
     * 13) 初始化：加载拍立得 + 开始渲染
     *************************************************************/
    // 初始相机
    cameraState.radius = 20;
    cameraState.targetRadius = 20;
    cameraState.yaw = 0;
    cameraState.targetYaw = 0;
    applyCamera(0.016);

    // 加载拍立得
    loadPolaroids();

    // 开启主循环
    animate();

    // 给用户提示
    statusEl.textContent = "已加载场景（点击开始体验开启摄像头）";
  </script>
</body>
</html>
