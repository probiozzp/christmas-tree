<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>3D æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #05080f; font-family: sans-serif; }
    #upload {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      color: #fff;
      user-select: none;
      font-size: 14px;
      line-height: 1.35;
      background: rgba(0,0,0,0.25);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
    }
    #upload input { margin-top: 6px; }
    #hint {
      position: fixed;
      bottom: 12px;
      left: 12px;
      z-index: 10;
      color: rgba(255,255,255,0.85);
      font-size: 12px;
      background: rgba(0,0,0,0.25);
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: 360px;
    }
    #err {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 20;
      color: #ffd7d7;
      font-size: 12px;
      background: rgba(80,0,0,0.45);
      padding: 10px 12px;
      border-radius: 10px;
      max-width: 420px;
      white-space: pre-wrap;
      display: none;
    }
  </style>
</head>
<body>

<div id="upload">
  ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ï¼ˆä½œä¸ºæ ‘ä¸Šè£…é¥°ï¼‰
  <br />
  <input type="file" id="fileInput" multiple accept="image/*" />
  <div style="margin-top:6px;opacity:.8">
    ä¹Ÿæ”¯æŒé¢„ç½®å›¾ç‰‡ï¼š<code>./assets/1.jpg</code> ç­‰
  </div>
</div>

<div id="hint">
  âœ… æ“ä½œæç¤ºï¼šå…è®¸æ‘„åƒå¤´å<br/>
  ğŸ‘‰ é£ŸæŒ‡æŒ‡å‘ï¼šé€‰ä¸­ç…§ç‰‡ï¼ˆhoverï¼‰<br/>
  ğŸ¤ æ‹‡æŒ‡+é£ŸæŒ‡æåˆï¼šæ”¾å¤§é€‰ä¸­ç…§ç‰‡ï¼ˆæåˆè¶Šç´§æ”¾å¤§è¶Šå¤§ï¼‰<br/>
  ğŸ¤ æŒç»­æåˆ 300msï¼šè¿›å…¥è¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰<br/>
  æ¾å¼€æåˆ / æ— æ‰‹ï¼šè‡ªåŠ¨é€€å‡º
</div>

<div id="err"></div>
<video id="video" style="display:none;"></video>

<script type="module">
/* ======================================================
 *  ä¾èµ–å¼•å…¥ï¼ˆæ”¹ä¸º unpkgï¼Œå›½å†…ä¸€èˆ¬æ›´ç¨³ï¼‰
 * ====================================================== */
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { Hands } from "https://unpkg.com/@mediapipe/hands/hands.js";
import { Camera } from "https://unpkg.com/@mediapipe/camera_utils/camera_utils.js";

/* ======================================================
 *  é”™è¯¯æ˜¾ç¤ºï¼ˆé¿å…é»‘å±æ— æç¤ºï¼‰
 * ====================================================== */
const errBox = document.getElementById("err");
window.addEventListener("error", (e) => {
  errBox.style.display = "block";
  errBox.textContent = "âŒ è¿è¡ŒæŠ¥é”™ï¼š\n" + (e?.message || e);
});
window.addEventListener("unhandledrejection", (e) => {
  errBox.style.display = "block";
  errBox.textContent = "âŒ Promise æŠ¥é”™ï¼š\n" + (e?.reason?.message || e?.reason || e);
});

/* ======================================================
 *  å…¨å±€å‚æ•°ï¼ˆå¯è°ƒï¼‰
 * ====================================================== */
const PARAMS = {
  TREE_HEIGHT: 6,
  TREE_RADIUS: 3,
  PARTICLE_COUNT: 4500,

  PINCH_MIN: 0.02,
  PINCH_MAX: 0.12,
  DETAIL_HOLD_MS: 300,

  NO_HAND_TIMEOUT_MS: 1200,   // æ— æ‰‹å¤šä¹…å›åˆ°é»˜è®¤
  ROTATE_SPEED: 0.002,
};

/* ======================================================
 *  Three.js åŸºç¡€åœºæ™¯
 * ====================================================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x05080f, 8, 22);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 3, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* æŸ”å…‰èƒŒæ™¯ï¼ˆå¯é€‰ï¼‰ */
scene.add(new THREE.AmbientLight(0xffffff, 0.2));

/* ======================================================
 *  ç²’å­åœ£è¯æ ‘ï¼ˆæ ‘å½¢ basePositions + å½“å‰ positionsï¼‰
 * ====================================================== */
const positions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const cloudPositions = new Float32Array(PARAMS.PARTICLE_COUNT * 3); // æ˜Ÿäº‘å½¢ç›®æ ‡

for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
  // æ ‘å½¢ï¼šé”¥ä½“
  const y = Math.random() * PARAMS.TREE_HEIGHT;
  const radius = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS;
  const angle = Math.random() * Math.PI * 2;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);

  // æ˜Ÿäº‘ï¼šç¯ç»•çƒå£³/äº‘å›¢
  const t = Math.random() * Math.PI * 2;
  const u = Math.random() * 2 - 1;
  const rr = 4 + Math.random() * 4;
  const cx = rr * Math.sqrt(1 - u*u) * Math.cos(t);
  const cy = 2 + rr * u * 0.35;
  const cz = rr * Math.sqrt(1 - u*u) * Math.sin(t);
  cloudPositions.set([cx, cy, cz], i * 3);
}

const geom = new THREE.BufferGeometry();
geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const colors = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const cGreen = new THREE.Color("#2cff9a");
const cGold  = new THREE.Color("#ffd27d");
const cWhite = new THREE.Color("#ffffff");
for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
  const r = Math.random();
  const c = r < 0.55 ? cGreen : (r < 0.85 ? cGold : cWhite);
  colors.set([c.r, c.g, c.b], i * 3);
}
geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const mat = new THREE.PointsMaterial({
  size: 0.06,
  transparent: true,
  opacity: 0.9,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  vertexColors: true
});

const treePoints = new THREE.Points(geom, mat);
scene.add(treePoints);

/* æ˜Ÿæ˜Ÿï¼ˆæ ‘é¡¶ï¼‰ */
const star = new THREE.Mesh(
  new THREE.SphereGeometry(0.26, 18, 18),
  new THREE.MeshBasicMaterial({ color: 0xffffcc })
);
star.position.set(0, PARAMS.TREE_HEIGHT + 0.3, 0);
scene.add(star);

/* ======================================================
 *  ç…§ç‰‡ç³»ç»Ÿï¼ˆé¢„ç½® + æ‰‹åŠ¨ä¸Šä¼ ï¼‰
 * ====================================================== */
const photoGroup = new THREE.Group();
scene.add(photoGroup);
const photoMeshes = [];

function placePhotoMesh(mesh) {
  // èºæ—‹/éšæœºæŒ‚åœ¨æ ‘å‘¨å›´
  const y = Math.random() * PARAMS.TREE_HEIGHT * 0.85 + 0.5;
  const r = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS + 0.6;
  const a = Math.random() * Math.PI * 2;
  mesh.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
  mesh.lookAt(0, y, 0);
}

function addPhotoFromTexture(texture) {
  texture.colorSpace = THREE.SRGBColorSpace;

  const geo = new THREE.PlaneGeometry(1, 1);
  const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1 });
  const mesh = new THREE.Mesh(geo, mat);

  placePhotoMesh(mesh);
  photoGroup.add(mesh);
  photoMeshes.push(mesh);
}

function addPhotoFromUrl(url) {
  const loader = new THREE.TextureLoader();
  loader.load(
    url,
    (tex) => addPhotoFromTexture(tex),
    undefined,
    (err) => {
      // é¢„ç½®å›¾ç‰‡ä¸å­˜åœ¨ä¹Ÿæ²¡å…³ç³»ï¼Œç»™å‡ºæç¤º
      console.warn("é¢„ç½®å›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", url, err);
    }
  );
}

/* é¢„ç½®å›¾ç‰‡ï¼ˆä½ å¯ä»¥åœ¨ä»“åº“ assets/ æ”¾ 1.jpg 2.jpg 3.jpgï¼‰ */
const defaultPhotos = [
  "./assets/1.jpg",
  "./assets/2.jpg",
  "./assets/3.jpg"
];
defaultPhotos.forEach(addPhotoFromUrl);

/* ç”¨æˆ·æ‰‹åŠ¨ä¸Šä¼  */
document.getElementById("fileInput").addEventListener("change", (e) => {
  const files = [...e.target.files];
  files.forEach(file => {
    const url = URL.createObjectURL(file);
    const loader = new THREE.TextureLoader();
    loader.load(url, (tex) => {
      addPhotoFromTexture(tex);
      // é‡Šæ”¾ blob URLï¼ˆé¿å…å†…å­˜å¢é•¿ï¼‰
      URL.revokeObjectURL(url);
    });
  });
});

/* ======================================================
 *  Raycasterï¼ˆé£ŸæŒ‡æŒ‡å‘ hover/é€‰ä¸­ï¼‰
 * ====================================================== */
const raycaster = new THREE.Raycaster();
let hoveredPhoto = null;

/* ======================================================
 *  æ‰‹åŠ¿çŠ¶æ€
 * ====================================================== */
let pinchStrength = 0;      // 0~1
let detailMode = false;
let lastPinchStart = 0;

let handX = 0;              // ç”¨äºå·¦å³ç§»åŠ¨æ—‹è½¬
let targetRotationY = 0;
let lastHandSeenAt = 0;

let mode = "TREE";          // TREE / CLOUD
let targetCloudMix = 0;     // 0=æ ‘å½¢ï¼Œ1=æ˜Ÿäº‘

/* ======================================================
 *  MediaPipe Hands åˆå§‹åŒ–
 * ====================================================== */
const hands = new Hands({
  locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults((results) => {
  const lm = results.multiHandLandmarks?.[0];
  if (!lm) return;

  lastHandSeenAt = performance.now();

  const indexTip = lm[8];
  const thumbTip = lm[4];

  // pinch è·ç¦»
  const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
  pinchStrength = THREE.MathUtils.clamp(
    (PARAMS.PINCH_MAX - d) / (PARAMS.PINCH_MAX - PARAMS.PINCH_MIN),
    0,
    1
  );

  // ç”¨æ‰‹çš„ x æ§åˆ¶æ—‹è½¬ï¼ˆ-0.5~0.5ï¼‰
  handX = indexTip.x - 0.5;
  targetRotationY = THREE.MathUtils.clamp(handX * 2.0, -1.2, 1.2);

  // Raycasterï¼šç”¨ indexTip çš„å±å¹•åæ ‡æ˜ å°„ NDC
  const ndc = { x: indexTip.x * 2 - 1, y: -(indexTip.y * 2 - 1) };
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(photoMeshes);
  hoveredPhoto = hits[0]?.object || null;

  // â€œå¼ å¼€/æ¡æ‹³â€è¿™é‡Œç”¨ä¸€ä¸ªç®€å•çš„å¯å‘å¼ï¼š
  // çœ‹é£ŸæŒ‡/ä¸­æŒ‡/æ— åæŒ‡/å°æŒ‡çš„æŒ‡å°–åˆ°æŒå¿ƒ(0ç‚¹)çš„è·ç¦»æ€»å’Œ
  const palm = lm[0];
  const tips = [lm[8], lm[12], lm[16], lm[20]];
  const sumDist = tips.reduce((acc, p) => acc + Math.hypot(p.x - palm.x, p.y - palm.y), 0);

  const OPEN_THRESHOLD = 0.55;  // å¯è°ƒ
  const FIST_THRESHOLD = 0.38;  // å¯è°ƒ

  if (sumDist > OPEN_THRESHOLD) {
    mode = "CLOUD";   // å¼ å¼€ï¼šæ•£å¼€
  } else if (sumDist < FIST_THRESHOLD) {
    mode = "TREE";    // æ¡æ‹³ï¼šèšåˆ
  }
  targetCloudMix = (mode === "CLOUD") ? 1 : 0;

  // è¯¦æƒ…æ¨¡å¼ï¼špinch å¼ºä¸”æŒç»­ 300ms
  if (pinchStrength > 0.8 && hoveredPhoto) {
    if (!lastPinchStart) lastPinchStart = performance.now();
    if (performance.now() - lastPinchStart > PARAMS.DETAIL_HOLD_MS) {
      detailMode = true;
    }
  } else {
    lastPinchStart = 0;
    detailMode = false;
  }
});

/* æ‘„åƒå¤´ */
const video = document.getElementById("video");
const cameraMP = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
cameraMP.start();

/* ======================================================
 *  åŠ¨ç”»å¾ªç¯
 * ====================================================== */
const tmpV3 = new THREE.Vector3();
let cloudMix = 0; // å½“å‰æ··åˆå€¼

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();

  // æ— æ‰‹å›é€€
  if (now - lastHandSeenAt > PARAMS.NO_HAND_TIMEOUT_MS) {
    pinchStrength = 0;
    detailMode = false;
    hoveredPhoto = null;
    mode = "TREE";
    targetCloudMix = 0;
    targetRotationY = 0;
  }

  // ç²’å­æ ‘ <-> æ˜Ÿäº‘ æ··åˆ
  cloudMix = THREE.MathUtils.lerp(cloudMix, targetCloudMix, 0.04);

  // å‘¼å¸/æ¼‚æµ® + æ··åˆç›®æ ‡ä½ç½®
  const pos = geom.attributes.position.array;
  for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
    const bi = i * 3;
    const bx = basePositions[bi];
    const by = basePositions[bi + 1];
    const bz = basePositions[bi + 2];

    const cx = cloudPositions[bi];
    const cy = cloudPositions[bi + 1];
    const cz = cloudPositions[bi + 2];

    // æ ‘å½¢æ¼‚æµ®
    const floatY = Math.sin((Date.now() * 0.001) + i) * 0.02;

    const tx = THREE.MathUtils.lerp(bx, cx, cloudMix);
    const ty = THREE.MathUtils.lerp(by + floatY, cy, cloudMix);
    const tz = THREE.MathUtils.lerp(bz, cz, cloudMix);

    pos[bi] = tx;
    pos[bi + 1] = ty;
    pos[bi + 2] = tz;
  }
  geom.attributes.position.needsUpdate = true;

  // åœºæ™¯æ—‹è½¬ï¼ˆå·¦å³ç§»åŠ¨æ‰‹ï¼‰
  treePoints.rotation.y = THREE.MathUtils.lerp(treePoints.rotation.y, targetRotationY, 0.08);
  photoGroup.rotation.y = treePoints.rotation.y;

  // æ˜Ÿæ˜Ÿè½»å¾®å‘¼å¸
  star.scale.setScalar(1 + Math.sin(Date.now() * 0.002) * 0.05);

  // ç…§ç‰‡ hover + pinch ç¼©æ”¾ + è¯¦æƒ…æ¨¡å¼æ·¡å‡º
  for (const m of photoMeshes) {
    const isHover = (hoveredPhoto === m);

    const targetScale = isHover
      ? (1 + pinchStrength * 1.6)   // pinch è¶Šå¼ºè¶Šå¤§
      : 1;

    m.scale.lerp(tmpV3.set(targetScale, targetScale, 1), 0.15);

    // æ·¡å‡ºå…¶ä»–å…ƒç´ 
    const baseOpacity = (detailMode && !isHover) ? 0.18 : 1;
    m.material.opacity = THREE.MathUtils.lerp(m.material.opacity, baseOpacity, 0.12);
  }

  // è¯¦æƒ…æ¨¡å¼ï¼šæŠŠé€‰ä¸­çš„ç…§ç‰‡æ‹‰åˆ°é•œå¤´å‰
  if (detailMode && hoveredPhoto) {
    hoveredPhoto.position.lerp(new THREE.Vector3(0, PARAMS.TREE_HEIGHT * 0.55, 2.2), 0.08);
  }

  // é»˜è®¤è½»å¾®è‡ªè½¬ï¼ˆåœ¨æ— æ‰‹æ—¶ä¹Ÿæœ‰ä¸€ç‚¹ç‚¹ï¼‰
  if (now - lastHandSeenAt > PARAMS.NO_HAND_TIMEOUT_MS) {
    treePoints.rotation.y += PARAMS.ROTATE_SPEED;
    photoGroup.rotation.y = treePoints.rotation.y;
  }

  renderer.render(scene, camera);
}

animate();

/* ======================================================
 *  resize
 * ====================================================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
