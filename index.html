<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grand Luxury Interactive Christmas Tree (Vanilla + Three.js + MediaPipe)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#05080f; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial; }
    #app { position:fixed; inset:0; }
    canvas.webgl { position:absolute; inset:0; width:100%; height:100%; display:block; }

    .hud {
      position: absolute; left: 14px; top: 14px; z-index: 10;
      padding: 12px 14px; border-radius: 16px;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92); backdrop-filter: blur(10px);
      max-width: 620px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
    }
    .title { font-weight: 800; letter-spacing: 0.2px; }
    .sub { font-size: 12px; opacity: 0.86; margin-top: 6px; line-height: 1.4; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap:wrap; margin-top: 10px; }
    button {
      appearance:none; border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 14px;
      cursor:pointer; font-weight: 700; font-size: 13px;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .debug { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: 0.86; margin-top: 10px; line-height: 1.35; white-space: pre; }

    .panel {
      position:absolute; right: 14px; top: 14px; z-index:10;
      width: 360px; border-radius: 16px; overflow:hidden;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.9);
    }
    .panelHead { display:flex; justify-content:space-between; align-items:center; padding: 10px 12px; font-size: 12px; border-bottom: 1px solid rgba(255,255,255,0.10); }
    .panelBody { position:relative; width: 100%; aspect-ratio: 16/9; background: #000; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); }
    canvas#overlay { position:absolute; inset:0; width:100%; height:100%; }
    .panelFoot { padding: 10px 12px; font-size: 11px; opacity: 0.78; border-top: 1px solid rgba(255,255,255,0.10); line-height: 1.35; white-space: pre-line; }
  </style>
</head>

<body>
  <div id="app">
    <canvas class="webgl" id="webgl"></canvas>

    <div class="hud">
      <div class="title">Grand Luxury Interactive Christmas Tree</div>
      <div class="sub">
        æ·±ç¥–æ¯ç»¿ + é«˜å…‰é‡‘è‰² + ç”µå½±çº§è¾‰å…‰ã€‚<br/>
        æ‰‹åŠ¿ï¼šå¼ å¼€â†’æ•£å¼€(CHAOS)ï¼›æ¡æ‹³â†’èšåˆ(FORMED)ï¼›å·¦å³æ»‘åŠ¨â†’ç¨³å®šæ—‹è½¬è§†è§’ï¼ˆä¸ç”©é£ï¼‰ã€‚<br/>
        æ‹ç«‹å¾—ï¼šé£ŸæŒ‡ hoverï¼›ğŸ¤ æåˆæ”¾å¤§ï¼›æåˆæ—¶ä¼šè‡ªåŠ¨é”å®šæœ€è¿‘ç…§ç‰‡ï¼›æ”¾å¤§å•å¼ æ—¶æ ‘æ•´ä½“åœæ­¢æ—‹è½¬ã€‚
      </div>

      <div class="row">
        <button id="btnStart">â–¶ å¼€å§‹ä½“éªŒï¼ˆå¼€å¯æ‘„åƒå¤´ï¼‰</button>
        <button id="btnReset">â†º é‡ç½®è§†è§’</button>
        <span id="status" style="font-size:12px; opacity:0.85;">æœªå¯åŠ¨</span>
      </div>

      <div class="debug" id="debug">loadingâ€¦</div>
    </div>

    <div class="panel">
      <div class="panelHead">
        <div>Hand Preview</div>
        <div id="camFlag" style="font-family: ui-monospace; opacity:0.8;">OFF</div>
      </div>
      <div class="panelBody">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="panelFoot">
å¦‚æœæ²¡å¼¹æƒé™ï¼šåœ°å€æ å°é” â†’ Camera â†’ Allow â†’ åˆ·æ–°ï¼ˆåŠ  ?v=æ•°å­—ï¼‰
æ³¨æ„ï¼šå¿…é¡» https æˆ– localhost æ‰èƒ½ç¨³å®šè®¿é—®æ‘„åƒå¤´
      </div>
    </div>
  </div>

  <!-- âœ… MediaPipe Handsï¼šå¸¸è§„ script å¼•å…¥ï¼ˆå¾—åˆ°å…¨å±€ Handsï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <!-- âœ… Three.js ç”¨ module -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /*************************************************************
     * 0) å·¥å…·
     *************************************************************/
    const clamp01 = (v) => Math.max(0, Math.min(1, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
    const deadzone = (v, dz) => (Math.abs(v) < dz ? 0 : (v > 0 ? (v - dz) / (1 - dz) : (v + dz) / (1 - dz)));

    /*************************************************************
     * 1) DOM
     *************************************************************/
    const canvas = document.getElementById("webgl");
    const btnStart = document.getElementById("btnStart");
    const btnReset = document.getElementById("btnReset");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const camFlagEl = document.getElementById("camFlag");

    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const octx = overlay.getContext("2d");

    /*************************************************************
     * 2) Three.js scene / camera / renderer
     *************************************************************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#05080f");
    scene.fog = new THREE.Fog("#05080f", 10, 55);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
    const treeCenter = new THREE.Vector3(0, 4, 0);

    const cameraState = {
      radius: 20,
      targetRadius: 20,
      yaw: 0,
      targetYaw: 0,
      pitch: 0.08,
      targetPitch: 0.08,
    };

    // âœ… æ›´ç¨³çš„å·¦å³æ§åˆ¶ï¼ˆé€Ÿåº¦ç§¯åˆ†ï¼‰
    const orbitInput = {
      yawVel: 0,
      targetYawVel: 0,
    };

    function applyCamera(dt) {
      cameraState.radius = damp(cameraState.radius, cameraState.targetRadius, 5.0, dt);
      cameraState.yaw    = damp(cameraState.yaw,    cameraState.targetYaw,    6.0, dt);
      cameraState.pitch  = damp(cameraState.pitch,  cameraState.targetPitch,  6.0, dt);

      const r = cameraState.radius;
      const yaw = cameraState.yaw;
      const pitch = cameraState.pitch;

      const x = Math.sin(yaw) * Math.cos(pitch) * r;
      const z = Math.cos(yaw) * Math.cos(pitch) * r;
      const y = Math.sin(pitch) * r;

      camera.position.set(x, y + treeCenter.y, z);
      camera.lookAt(treeCenter);
    }

    /*************************************************************
     * 3) ç¯å…‰
     *************************************************************/
    scene.add(new THREE.AmbientLight(0xffffff, 0.14));

    const key = new THREE.DirectionalLight("#ffd27d", 2.6);
    key.position.set(8, 14, 10);
    scene.add(key);

    const fill = new THREE.DirectionalLight("#9bdcff", 0.55);
    fill.position.set(-10, 8, -12);
    scene.add(fill);

    const emeraldGlow = new THREE.PointLight("#4cffc0", 0.25, 80);
    emeraldGlow.position.set(0, 6, 12);
    scene.add(emeraldGlow);

    /*************************************************************
     * 4) åœ£è¯æ ‘æ ¸å¿ƒï¼ˆä¿æŒä½ åŸæ¥çš„æ„æˆï¼‰
     *************************************************************/
    const MODE = { FORMED: 0, CHAOS: 1 };
    let mode = MODE.FORMED;

    let mix = 0;
    let targetMix = 0;

    const TREE_H = 6.6;
    const TREE_R = 3.6;

    const root = new THREE.Group();
    scene.add(root);

    /*************************************************************
     * 4.1 æ ‘è¡¨é¢é—ªçƒç²’å­ï¼ˆPointsï¼‰
     *************************************************************/
    const SURFACE_COUNT = 8000;
    const surfaceGeo = new THREE.BufferGeometry();
    const surfacePos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceTarget = new Float32Array(SURFACE_COUNT * 3);
    const surfaceChaos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceSeed = new Float32Array(SURFACE_COUNT);

    function conePoint() {
      const y = Math.random() * TREE_H;
      const radius = (1 - y / TREE_H) * TREE_R;
      const a = Math.random() * Math.PI * 2;
      const x = Math.cos(a) * radius + (Math.random() - 0.5) * 0.12;
      const z = Math.sin(a) * radius + (Math.random() - 0.5) * 0.12;
      return new THREE.Vector3(x, y, z);
    }
    function chaosPoint() {
      const rr = 16 + Math.random() * 20;
      return new THREE.Vector3(
        (Math.random() - 0.5) * rr,
        (Math.random() - 0.5) * rr * 0.7 + 3.2,
        (Math.random() - 0.5) * rr
      );
    }

    for (let i = 0; i < SURFACE_COUNT; i++) {
      const t = conePoint();
      const c = chaosPoint();
      surfaceTarget.set([t.x, t.y, t.z], i * 3);
      surfaceChaos.set([c.x, c.y, c.z], i * 3);
      surfacePos.set([t.x, t.y, t.z], i * 3);
      surfaceSeed[i] = Math.random();
    }
    surfaceGeo.setAttribute("position", new THREE.BufferAttribute(surfacePos, 3));
    surfaceGeo.setAttribute("aTarget", new THREE.BufferAttribute(surfaceTarget, 3));
    surfaceGeo.setAttribute("aChaos", new THREE.BufferAttribute(surfaceChaos, 3));
    surfaceGeo.setAttribute("aSeed", new THREE.BufferAttribute(surfaceSeed, 1));

    const surfaceMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },
        uEmerald: { value: new THREE.Color("#0a3a2c") },
        uGold: { value: new THREE.Color("#ffd27d") },
        uWhite: { value: new THREE.Color("#ffffff") },
      },
      vertexShader: `
        attribute vec3 aTarget;
        attribute vec3 aChaos;
        attribute float aSeed;

        uniform float uTime;
        uniform float uMix;

        varying float vGlow;
        varying float vTw;

        float hash(float n){ return fract(sin(n)*43758.5453123); }

        void main(){
          vec3 p = mix(aTarget, aChaos, uMix);

          float n = hash(aSeed*17.0);
          p.y += sin(uTime*1.25 + aSeed*6.2831) * 0.035 * (0.2 + 0.8*n);
          p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
          p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;

          vGlow = smoothstep(1.6, 6.6, p.y);

          float tw = sin(uTime*3.1 + aSeed*40.0) * 0.5 + 0.5;
          vTw = smoothstep(0.86, 1.0, tw) * (0.25 + 0.75*vGlow);

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = mix(7.0, 18.0, vGlow);
          size += vTw * 8.0;
          size *= (0.85 + n*0.4);
          gl_PointSize = size * (1.0 / -mv.z);
        }
      `,
      fragmentShader: `
        precision highp float;

        uniform vec3 uEmerald;
        uniform vec3 uGold;
        uniform vec3 uWhite;

        varying float vGlow;
        varying float vTw;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.28, 0.0, d);
          float halo = smoothstep(0.62, 0.15, d);

          vec3 base = mix(uEmerald, uGold, vGlow*0.95);
          vec3 spark = mix(uGold, uWhite, 0.6);
          vec3 col = base + spark * vTw * (0.35 + core*0.9);

          float a = halo;
          gl_FragColor = vec4(col, a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const surfacePoints = new THREE.Points(surfaceGeo, surfaceMat);
    root.add(surfacePoints);

    /*************************************************************
     * 4.2 æŒ‚ä»¶ InstancedMeshï¼ˆä¿æŒä½ åŸæ¥çš„ï¼‰
     *************************************************************/
    const ORN_COUNT = 900;
    const ornGroup = new THREE.Group();
    root.add(ornGroup);

    const ballCount = Math.floor(ORN_COUNT * 0.55);
    const boxCount  = Math.floor(ORN_COUNT * 0.25);
    const lampCount = ORN_COUNT - ballCount - boxCount;

    function makeInstanced(geo, mat, count) {
      const im = new THREE.InstancedMesh(geo, mat, count);
      im.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      return im;
    }

    const ballGeo = new THREE.SphereGeometry(0.08, 12, 12);
    const boxGeo  = new THREE.BoxGeometry(0.13, 0.13, 0.13);
    const lampGeo = new THREE.SphereGeometry(0.045, 10, 10);

    const gold = new THREE.Color("#ffd27d");
    const emerald = new THREE.Color("#0a3a2c");

    const ballMat = new THREE.MeshStandardMaterial({ color: gold, metalness: 0.75, roughness: 0.18, emissive: gold, emissiveIntensity: 0.12 });
    const boxMat  = new THREE.MeshStandardMaterial({ color: emerald, metalness: 0.40, roughness: 0.28, emissive: gold, emissiveIntensity: 0.06 });
    const lampMat = new THREE.MeshStandardMaterial({ color: new THREE.Color("#ffffff"), metalness: 0.1, roughness: 0.15, emissive: new THREE.Color("#ffffff"), emissiveIntensity: 0.55 });

    const balls = makeInstanced(ballGeo, ballMat, ballCount);
    const boxes = makeInstanced(boxGeo, boxMat, boxCount);
    const lamps = makeInstanced(lampGeo, lampMat, lampCount);

    ornGroup.add(balls, boxes, lamps);

    const ornTarget = [];
    const ornChaos = [];

    function randomConeOrn() {
      const y = Math.random() * (TREE_H * 0.85) + 0.6;
      const r = (1 - y / TREE_H) * TREE_R + 0.25;
      const a = Math.random() * Math.PI * 2;
      return new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
    }

    for (let i = 0; i < ORN_COUNT; i++) {
      ornTarget.push(randomConeOrn());
      ornChaos.push(chaosPoint());
    }

    const tmpObj = new THREE.Object3D();

    function updateOrnaments(dt, time) {
      const tMix = mix;
      const breathe = (Math.sin(time * 1.2) * 0.5 + 0.5) * 0.06;

      for (let i = 0; i < ballCount; i++) {
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.6 + i * 0.03) * 0.02;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.7 + i) * 0.15,
          Math.cos(time * 0.6 + i) * 0.2,
          Math.sin(time * 0.5 + i) * 0.1
        );
        const s = 1.0 + breathe;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        balls.setMatrixAt(i, tmpObj.matrix);
      }
      balls.instanceMatrix.needsUpdate = true;

      for (let j = 0; j < boxCount; j++) {
        const i = ballCount + j;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.1 + i * 0.02) * 0.015;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.3 + i) * 0.25,
          Math.cos(time * 0.35 + i) * 0.35,
          Math.sin(time * 0.28 + i) * 0.2
        );
        const s = 1.0 + breathe * 0.8;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        boxes.setMatrixAt(j, tmpObj.matrix);
      }
      boxes.instanceMatrix.needsUpdate = true;

      for (let k = 0; k < lampCount; k++) {
        const i = ballCount + boxCount + k;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 2.6 + i * 0.05) * 0.03;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(0, 0, 0);
        const tw = (Math.sin(time * 4.5 + i * 0.9) * 0.5 + 0.5);
        const s = 1.0 + tw * 0.6;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        lamps.setMatrixAt(k, tmpObj.matrix);
      }
      lamps.instanceMatrix.needsUpdate = true;
    }

    /*************************************************************
     * 4.3 é¡¶éƒ¨â€œç«–ç€çš„äº”è§’æ˜Ÿâ€
     *************************************************************/
    function makeRadialTexture() {
      const c = document.createElement("canvas");
      c.width = 256; c.height = 256;
      const ctx = c.getContext("2d");
      const g = ctx.createRadialGradient(128,128,0,128,128,128);
      g.addColorStop(0.0, "rgba(255,210,125,0.55)");
      g.addColorStop(0.25,"rgba(255,210,125,0.25)");
      g.addColorStop(0.6, "rgba(255,210,125,0.08)");
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,256,256);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const glowTex = makeRadialTexture();

    function makeFivePointStarShape(R = 0.46, r = 0.20) {
      const shape = new THREE.Shape();
      const pts = [];
      const n = 5;
      const start = -Math.PI / 2;
      for (let i = 0; i < n * 2; i++) {
        const ang = start + (i * Math.PI) / n;
        const rad = (i % 2 === 0) ? R : r;
        pts.push(new THREE.Vector2(Math.cos(ang) * rad, Math.sin(ang) * rad));
      }
      shape.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) shape.lineTo(pts[i].x, pts[i].y);
      shape.closePath();
      return shape;
    }

    const star = new THREE.Group();
    star.position.set(0, TREE_H + 0.55, 0);
    root.add(star);

    const starGeo = new THREE.ExtrudeGeometry(makeFivePointStarShape(), {
      depth: 0.12,
      bevelEnabled: true,
      bevelThickness: 0.03,
      bevelSize: 0.02,
      bevelSegments: 2,
      curveSegments: 10,
    });
    starGeo.center();

    const starMat = new THREE.MeshStandardMaterial({
      color: "#ffd27d",
      metalness: 0.95,
      roughness: 0.12,
      emissive: "#ffd27d",
      emissiveIntensity: 0.9,
    });

    const starMesh = new THREE.Mesh(starGeo, starMat);
    star.add(starMesh);

    const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex,
      color: "#ffd27d",
      transparent: true,
      opacity: 0.65,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    }));
    glowSprite.scale.set(3.6, 3.6, 1);
    star.add(glowSprite);

    /*************************************************************
     * 5) ç™½è‰²ç²’å­å…‰æ™•ï¼ˆHaloï¼‰
     *************************************************************/
    const HALO_COUNT = 2200;
    const haloGeo = new THREE.BufferGeometry();
    const haloPos = new Float32Array(HALO_COUNT * 3);
    const haloSeed = new Float32Array(HALO_COUNT);

    for (let i = 0; i < HALO_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const rad = 5.2 + Math.random() * 2.0;
      const y = 3.8 + (Math.random() - 0.5) * 2.0;
      haloPos.set([Math.cos(a) * rad, y, Math.sin(a) * rad], i * 3);
      haloSeed[i] = Math.random();
    }
    haloGeo.setAttribute("position", new THREE.BufferAttribute(haloPos, 3));
    haloGeo.setAttribute("aSeed", new THREE.BufferAttribute(haloSeed, 1));

    const haloMat = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0 } },
      vertexShader: `
        attribute float aSeed;
        uniform float uTime;
        varying float vA;
        void main(){
          vec3 p = position;

          float t = uTime;
          float wob = sin(t*0.8 + aSeed*6.2831) * 0.15;
          float spin = (t*0.18 + aSeed*6.2831);

          float cs = cos(spin), sn = sin(spin);
          p.xz = mat2(cs, -sn, sn, cs) * p.xz;

          p.y += wob;

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = 4.0 + (sin(t*2.2 + aSeed*30.0)*0.5+0.5)*4.0;
          gl_PointSize = size * (1.0 / -mv.z);

          vA = 0.25 + (sin(t*1.6 + aSeed*20.0)*0.5+0.5)*0.35;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float a = smoothstep(0.6, 0.05, d) * vA;
          gl_FragColor = vec4(vec3(1.0), a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const halo = new THREE.Points(haloGeo, haloMat);
    root.add(halo);

    /*************************************************************
     * 6) âœ… æ–°å¢ï¼šé‡‘è‰²èºæ—‹ä¸Šå‡å‘å…‰æ¡å¸¦ï¼ˆç»•æ ‘ä¸Šå‡ï¼‰
     *************************************************************/
    function createSpiralRibbon() {
  const points = [];
  const turns = 8.2;                  // åœˆæ•°å¯å¾®è°ƒï¼šè¶Šå¤§è¶Šå¯†
  const height = TREE_H + 0.55;        // æ¡å¸¦æœ€é«˜åˆ°æ˜Ÿæ˜Ÿä¸‹æ–¹ä¸€ç‚¹
  const surfaceOffset = 0.10;          // ç¦»æ ‘è¡¨é¢â€œè´´è¿‘â€ç¨‹åº¦ï¼šè¶Šå°è¶Šè´´

  for (let i = 0; i <= 280; i++) {
    const t = i / 280;

    // è¿™æ¡ ribbon çš„ yï¼ˆä»æ ‘åº•åˆ°æ¥è¿‘æ ‘é¡¶ï¼‰
    const y = t * height;

    // âœ… å…³é”®ï¼šåœ†é”¥åœ¨è¯¥é«˜åº¦çš„â€œè¡¨é¢åŠå¾„â€
    // coneR åœ¨ y=0 æœ€å¤§ï¼Œy=height æœ€å°ï¼ˆè¶‹è¿‘ 0ï¼‰
    const coneR = Math.max(0.02, (1.0 - (y / TREE_H)) * TREE_R);

    // âœ… è®©æ¡å¸¦è´´ç€æ ‘è¡¨é¢ï¼šåŠå¾„ = coneR + å¾ˆå°çš„ offset
    // ä½ è¦æ›´è´´å°±æŠŠ surfaceOffset è°ƒåˆ° 0.05ï½0.08
    const radius = coneR + surfaceOffset;

    // èºæ—‹è§’åº¦
    const angle = t * Math.PI * 2 * turns;

    points.push(new THREE.Vector3(
      Math.cos(angle) * radius,
      y + 0.20,                        // æ•´ä½“æŠ¬é«˜ä¸€ç‚¹ï¼Œé¿å…ç©¿å…¥åœ°é¢
      Math.sin(angle) * radius
    ));
  }

  const curve = new THREE.CatmullRomCurve3(points);

  // âœ… Tube åŠå¾„æ”¹å°ï¼šé¿å…â€œåœ†æŸ±ç®¡å­æ„Ÿâ€
  const geo = new THREE.TubeGeometry(curve, 360, 0.035, 10, false);

  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color("#ffd27d") },
    },
    vertexShader: `
      varying float vT;
      void main(){
        vT = uv.x;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 uColor;
      uniform float uTime;
      varying float vT;
      void main(){
        // é«˜äº®åƒâ€œé‡‘ç®”æ‰«å…‰â€ä¸€æ ·æ²¿æ¡å¸¦æµåŠ¨
        float scan = sin(vT*26.0 - uTime*3.4)*0.5+0.5;
        float core = smoothstep(0.35, 1.0, scan);
        float a = 0.10 + core * 0.85;    // æ›´â€œè´´ç€æ ‘â€çš„å…‰å¸¦ï¼Œé€æ˜ä¸€ç‚¹æ›´è‡ªç„¶
        gl_FragColor = vec4(uColor, a);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 2;
  return { mesh, mat };
}    
    

    const ribbon = createSpiralRibbon();
    root.add(ribbon.mesh);

    /*************************************************************
     * 7) æ‹ç«‹å¾—ç…§ç‰‡æŒ‚ä»¶ï¼ˆé»˜è®¤å°±æ˜¾ç¤ºç…§ç‰‡ï¼‰
     *    âœ… è‡ªåŠ¨æ‰«æ assets/1.jpg ~ assets/60.jpg
     *    âœ… æ²¿èºæ—‹ä½ç½®é¢„æ’
     *************************************************************/
    const raycaster = new THREE.Raycaster();
    const polaroidGroup = new THREE.Group();
    root.add(polaroidGroup);

    const textureLoader = new THREE.TextureLoader();
    const polaroids = [];

    function makePolaroid(tex) {
      tex.colorSpace = THREE.SRGBColorSpace;

      const g = new THREE.Group();

      const cardW = 1.18, cardH = 1.48;
      const photoW = 1.02, photoH = 0.86;
      const bottomH = 0.30;

      const frameMat = new THREE.MeshStandardMaterial({
        color: "#ffffff", roughness: 0.42, metalness: 0.05, transparent: true, opacity: 1
      });
      const frame = new THREE.Mesh(new THREE.PlaneGeometry(cardW, cardH), frameMat);
      g.add(frame);

      // âœ… é»˜è®¤å°±æ˜¾ç¤ºç…§ç‰‡
      const photoMat = new THREE.MeshStandardMaterial({
        map: tex, roughness: 0.25, metalness: 0.05, transparent: true, opacity: 1
      });
      const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), photoMat);
      photo.position.set(0, 0.18, 0.002);
      g.add(photo);

      const bottomMat = new THREE.MeshStandardMaterial({
        color: "#f5f5f5", roughness: 0.75, metalness: 0.0, transparent: true, opacity: 1
      });
      const bottom = new THREE.Mesh(new THREE.PlaneGeometry(photoW, bottomH), bottomMat);
      bottom.position.set(0, -0.46, 0.002);
      g.add(bottom);

      const hit = new THREE.Mesh(
        new THREE.PlaneGeometry(cardW * 1.12, cardH * 1.12),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
      );
      hit.position.set(0, 0, 0.004);
      g.add(hit);

      const hook = new THREE.Mesh(
        new THREE.BoxGeometry(0.14, 0.11, 0.04),
        new THREE.MeshStandardMaterial({ color: "#ffd27d", metalness: 0.85, roughness: 0.18 })
      );
      hook.position.set(0, cardH * 0.52, 0.01);
      g.add(hook);

      const wire = new THREE.Mesh(
        new THREE.CylinderGeometry(0.008, 0.008, 0.7, 10),
        new THREE.MeshBasicMaterial({ color: "#ffffff", transparent: true, opacity: 0.45 })
      );
      wire.position.set(0, cardH * 0.52 + 0.35, 0.0);
      g.add(wire);

      const gloss = new THREE.Sprite(new THREE.SpriteMaterial({
        map: glowTex, color: "#ffffff", transparent: true, opacity: 0.10,
        blending: THREE.AdditiveBlending, depthWrite: false
      }));
      gloss.scale.set(1.8, 2.2, 1);
      gloss.position.set(0.0, 0.05, 0.03);
      g.add(gloss);

      g.userData = { frameMat, photoMat, bottomMat, glossMat: gloss.material, hit };
      return g;
    }

    // èºæ—‹å¸ƒå±€ï¼šç¬¬ i å¼ ï¼ˆtotal å¼ ï¼‰
    function spiralPhotoPosition(i, total) {
      const t = (total <= 1) ? 0.0 : (i / (total - 1));
      const turns = 6.4;
      const angle = t * Math.PI * 2 * turns;

      const y = 0.85 + t * TREE_H * 0.85;
      const r = (TREE_R + 0.95) * (1.0 - t * 0.10); // é¡¶éƒ¨ç•¥æ”¶

      return new THREE.Vector3(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      );
    }

    // æ‰«æ assets/1..max çš„å›¾ç‰‡æ˜¯å¦å­˜åœ¨
    async function discoverAssetsImages(max = 60) {
      const urls = [];
      let missStreak = 0;

      for (let i = 1; i <= max; i++) {
        const url = `./assets/${i}.jpg`;

        try {
          // ç”¨ fetch æ£€æŸ¥æ˜¯å¦å­˜åœ¨ï¼ˆåŒåŸŸä¸‹ OKï¼‰
          const res = await fetch(url, { method: "GET", cache: "no-store" });
          if (res.ok) {
            urls.push(url);
            missStreak = 0;
          } else {
            missStreak++;
          }
        } catch {
          missStreak++;
        }

        // è¿ç»­é”™å¤ªå¤šå°±æå‰åœæ­¢ï¼ˆé¿å…å¤§é‡ 404ï¼‰
        if (missStreak >= 8 && urls.length >= 1) break;
      }

      return urls;
    }

    async function loadPolaroidsAuto() {
      const urls = await discoverAssetsImages(60);
      statusEl.textContent = urls.length ? `å‘ç° assets å›¾ç‰‡ï¼š${urls.length} å¼ ` : `æœªå‘ç° assets/1.jpgâ€¦ï¼ˆè¯·æ”¾å…¥ assets ç›®å½•ï¼‰`;

      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        try {
          const tex = await new Promise((resolve, reject) => {
            textureLoader.load(url, resolve, undefined, reject);
          });

          const card = makePolaroid(tex);

          // å…ˆå ä½ï¼šåé¢ç»Ÿä¸€æŒ‰ total é‡æ–°æ’
          card.userData.index = i;

          // chaos / target åŒåæ ‡
          const target = spiralPhotoPosition(i, urls.length);
          const chaos = chaosPoint();
          card.userData.target = target;
          card.userData.chaos = chaos;
          card.userData.baseScale = 1.0;

          card.position.copy(target);
          card.lookAt(0, target.y, 0);
          card.rotateZ((Math.random() - 0.5) * 0.35);

          polaroidGroup.add(card);
          polaroids.push(card);
        } catch (e) {
          console.warn("åŠ è½½å›¾ç‰‡å¤±è´¥ï¼š", url, e);
        }
      }

      // æ’å®Œåå†è½»å¾®æŠ–åŠ¨ä¸€ä¸‹å±‚æ¬¡ï¼ˆé¿å…å®Œå…¨æœºæ¢°ï¼‰
      for (let i = 0; i < polaroids.length; i++) {
        const card = polaroids[i];
        const t = card.userData.target.clone();
        t.x += (Math.random() - 0.5) * 0.18;
        t.z += (Math.random() - 0.5) * 0.18;
        t.y += (Math.random() - 0.5) * 0.10;
        card.userData.target.copy(t);
        card.position.copy(t);
      }
    }

    /*************************************************************
     * 8) æ‰‹åŠ¿ç³»ç»Ÿï¼šMediaPipe Hands
     *************************************************************/
    let started = false;
    let mpHands = null;
    let stream = null;

    const handState = {
      hasHand: false,
      indexNDC: null,
      pinch: 0,
      open: false,
      fist: false,
      yaw: 0,
      roll: 0,
      size: 0,
      lastSeen: 0,
      hoverIndex: -1,
      selectedIndex: -1,
      detailMode: false,
      pinchHoldStart: 0
    };

    function drawLandmarks(lm) {
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;

      const dpr = Math.min(devicePixelRatio || 1, 2);
      if (overlay.width !== Math.floor(w * dpr) || overlay.height !== Math.floor(h * dpr)) {
        overlay.width = Math.floor(w * dpr);
        overlay.height = Math.floor(h * dpr);
        octx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      octx.clearRect(0, 0, w, h);

      if (!lm) return;

      octx.fillStyle = "rgba(255,210,125,0.95)";
      for (const p of lm) {
        octx.beginPath();
        octx.arc(p.x * w, p.y * h, 4, 0, Math.PI * 2);
        octx.fill();
      }
    }

    function hysteresis(value, onTh, offTh, current) {
      if (!current && value > onTh) return true;
      if (current && value < offTh) return false;
      return current;
    }

    function computeGestures(lm) {
      const wrist = lm[0];
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const midMcp = lm[9];
      const indexMcp = lm[5];
      const pinkyMcp = lm[17];

      let minX=1, minY=1, maxX=0, maxY=0;
      for (const p of lm) {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
      }
      const size = Math.hypot(maxX - minX, maxY - minY);

      const dPin = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
      let pinch = (PINCH_MAX - dPin) / (PINCH_MAX - PINCH_MIN);
      pinch = clamp01(pinch);

      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const openScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - wrist.x, p.y - wrist.y), 0);
      const fistScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - midMcp.x, p.y - midMcp.y), 0);

      handState.open = hysteresis(openScoreRaw, 0.62, 0.50, handState.open);
      handState.fist = hysteresis(1.0 - fistScoreRaw, 0.32, 0.22, handState.fist);

      const centerX = (minX + maxX) * 0.5;
      let yaw = -((centerX - 0.5) * 2);

      const vx = pinkyMcp.x - indexMcp.x;
      const vy = pinkyMcp.y - indexMcp.y;
      const angle = Math.atan2(vy, vx);
      let roll = THREE.MathUtils.clamp(angle / 1.2, -1, 1);

      const ndcX = - (indexTip.x * 2 - 1);
      const ndcY = - (indexTip.y * 2 - 1);

      return { pinch, yaw, roll, size, ndcX, ndcY };
    }

    async function startMediaPipe() {
      if (started) return;
      started = true;
      btnStart.disabled = true;

      statusEl.textContent = "è¯·æ±‚æ‘„åƒå¤´æƒé™â€¦";
      camFlagEl.textContent = "ON";

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();

      mpHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      mpHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: true
      });

      let inFlight = false;

      mpHands.onResults((results) => {
        const lm = results?.multiHandLandmarks?.[0];

        if (!lm) {
          drawLandmarks(null);
          handState.hasHand = false;
          return;
        }

        handState.hasHand = true;
        handState.lastSeen = performance.now();

        drawLandmarks(lm);

        const g = computeGestures(lm);

        const a = 0.18;
        handState.pinch = lerp(handState.pinch, g.pinch, a);
        handState.yaw   = lerp(handState.yaw,   g.yaw,   a);
        handState.roll  = lerp(handState.roll,  g.roll,  a);
        handState.size  = lerp(handState.size,  g.size,  a);

        handState.indexNDC = { x: g.ndcX, y: g.ndcY };

        if (handState.fist) mode = MODE.FORMED;
        else if (handState.open) mode = MODE.CHAOS;

        const dx = deadzone(handState.yaw, 0.14);
        const rollAssist = deadzone(handState.roll, 0.25) * 0.35;
        orbitInput.targetYawVel = THREE.MathUtils.clamp((dx * 1.7 + rollAssist) * 1.25, -2.2, 2.2);
      });

      const pump = async () => {
        if (!mpHands) return;
        if (video.readyState >= 2 && !inFlight) {
          inFlight = true;
          try { await mpHands.send({ image: video }); } catch(e) {}
          inFlight = false;
        }
        requestAnimationFrame(pump);
      };
      requestAnimationFrame(pump);

      statusEl.textContent = "æ‘„åƒå¤´å·²å¼€å¯ âœ…";
    }

    btnStart.addEventListener("click", async () => {
      try {
        await startMediaPipe();
      } catch (e) {
        console.error(e);
        alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ã€‚è¯·æ£€æŸ¥ï¼šåœ°å€æ å°é”â†’Camera Allowï¼›å¿…é¡» https æˆ– localhostï¼›æˆ–ç³»ç»Ÿéšç§è®¾ç½®ã€‚");
        statusEl.textContent = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ âŒ";
      }
    });

    btnReset.addEventListener("click", () => {
      orbitInput.yawVel = 0;
      orbitInput.targetYawVel = 0;
      cameraState.targetYaw = 0;
      cameraState.targetPitch = 0.08;
      cameraState.targetRadius = 20;
    });

    /*************************************************************
     * 9) Raycaster hover + pinch è‡ªåŠ¨é”æœ€è¿‘ç…§ç‰‡
     *************************************************************/
    function updateRaycastHover() {
      if (!handState.hasHand || !handState.indexNDC || polaroids.length === 0) {
        handState.hoverIndex = -1;
        return;
      }

      raycaster.setFromCamera(handState.indexNDC, camera);
      const hits = raycaster.intersectObjects(polaroidGroup.children, true);

      if (!hits.length) {
        handState.hoverIndex = -1;
        return;
      }

      let obj = hits[0].object;
      while (obj && obj.parent && obj.parent !== polaroidGroup) obj = obj.parent;
      const idx = obj?.userData?.index;
      handState.hoverIndex = (typeof idx === "number") ? idx : -1;
    }

    function findNearestPolaroidToCamera() {
      if (!polaroids.length) return -1;
      let best = -1;
      let bestD = Infinity;
      const camPos = camera.position;
      const wp = new THREE.Vector3();

      for (const card of polaroids) {
        card.getWorldPosition(wp);
        const d = wp.distanceTo(camPos);
        if (d < bestD) { bestD = d; best = card.userData.index; }
      }
      return best;
    }

    /*************************************************************
     * 10) æ›´æ–°ï¼šè¡¨é¢ç²’å­ & æ‹ç«‹å¾—
     *************************************************************/
    function updateSurface(time) {
      surfaceMat.uniforms.uTime.value = time;
      surfaceMat.uniforms.uMix.value = mix;
    }

    function updatePolaroids(dt, time) {
      const tMix = mix;

      // pinch æ—¶è‹¥æ²¡ hoverï¼Œå°±é”æœ€è¿‘ç…§ç‰‡
      const pinchActive = handState.hasHand && handState.pinch > 0.22;
      if (pinchActive && handState.hoverIndex < 0) {
        handState.hoverIndex = findNearestPolaroidToCamera();
      }

      // è¯¦æƒ…æ¨¡å¼ï¼špinch æŒç»­ 300ms
      const PINCH_DETAIL_ON = 0.72;
      const hovering = (handState.hoverIndex >= 0);

      if (hovering && handState.pinch > PINCH_DETAIL_ON) {
        if (!handState.pinchHoldStart) handState.pinchHoldStart = performance.now();
        if (performance.now() - handState.pinchHoldStart > 300) {
          handState.detailMode = true;
          handState.selectedIndex = handState.hoverIndex;
        }
      } else {
        handState.pinchHoldStart = 0;
        handState.detailMode = false;
      }

      for (const card of polaroids) {
        const idx = card.userData.index;
        const target = card.userData.target;
        const chaos = card.userData.chaos;

        const isHover = (idx === handState.hoverIndex);
        const isSelected = (idx === handState.selectedIndex) && handState.detailMode;

        const p = new THREE.Vector3(
          lerp(target.x, chaos.x, tMix),
          lerp(target.y, chaos.y, tMix),
          lerp(target.z, chaos.z, tMix)
        );

        if (!isSelected) {
          card.position.lerp(p, 0.22);
          card.lookAt(0, card.position.y, 0);
          card.rotateZ(Math.sin(time * 0.9 + idx) * 0.04);
        } else {
          card.position.lerp(new THREE.Vector3(0, 4.2, 6.0), 0.12);
          card.rotation.x = damp(card.rotation.x, 0, 10, dt);
          card.rotation.y = damp(card.rotation.y, 0, 10, dt);
          card.rotation.z = damp(card.rotation.z, 0, 10, dt);
        }

        const pinch = handState.pinch;
        const base = isSelected ? 2.1 : 1.0;

        // pinch æ”¾å¤§ï¼šå¯¹ hoverï¼ˆæˆ–æœ€è¿‘é”å®šï¼‰ç”Ÿæ•ˆ
        const zoom = isHover ? (1.0 + pinch * 2.2) : 1.0;
        const targetScale = base * zoom;

        card.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.18);

        // âœ… é»˜è®¤ç…§ç‰‡å¯è§ï¼šopacity ä¸å†è´Ÿè´£â€œæ˜¾ç¤º/ä¸æ˜¾ç¤ºâ€
        const fadeOthers = handState.detailMode && !isSelected;
        const opacityTarget = fadeOthers ? 0.18 : 1.0;

        const { frameMat, photoMat, bottomMat, glossMat } = card.userData;
        frameMat.opacity  = damp(frameMat.opacity,  opacityTarget, 10, dt);
        photoMat.opacity  = damp(photoMat.opacity,  opacityTarget, 10, dt);
        bottomMat.opacity = damp(bottomMat.opacity, opacityTarget, 10, dt);

        const gl = (Math.sin(time * 1.7 + idx) * 0.5 + 0.5);
        const glossTarget = (isHover ? 0.30 : 0.12) * gl;
        glossMat.opacity = damp(glossMat.opacity, glossTarget, 10, dt);
      }
    }

    /*************************************************************
     * 11) æ— æ‰‹å›å½’
     *************************************************************/
    function noHandFallback(now) {
      if (!handState.hasHand) {
        if (now - handState.lastSeen > 1000) {
          mode = MODE.FORMED;
          orbitInput.targetYawVel = 0;
          orbitInput.yawVel = damp(orbitInput.yawVel, 0, 6.0, 1/60);

          cameraState.targetYaw = damp(cameraState.targetYaw, 0, 3.0, 1/60);
          cameraState.targetRadius = 20;

          handState.pinch = damp(handState.pinch, 0, 6.0, 1/60);
          handState.hoverIndex = -1;
          handState.selectedIndex = -1;
          handState.detailMode = false;
        }
      }
    }

    /*************************************************************
     * 12) ä¸»å¾ªç¯
     *************************************************************/
    let lastT = performance.now() * 0.001;
    let rootSpin = 0;

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now() * 0.001;
      const dt = Math.min(0.033, now - lastT);
      lastT = now;

      // çŠ¶æ€æœºæ··åˆ
      targetMix = (mode === MODE.CHAOS) ? 1 : 0;
      mix = damp(mix, targetMix, 2.6, dt);

      // â­ æ˜Ÿæ˜Ÿå§‹ç»ˆç«–ç€é¢å¯¹ç›¸æœº
      starMesh.lookAt(camera.position);
      glowSprite.material.opacity = 0.55 + (Math.sin(now * 2.0) * 0.5 + 0.5) * 0.22;

      // halo & ribbon åŠ¨èµ·æ¥
      haloMat.uniforms.uTime.value = now;
      ribbon.mat.uniforms.uTime.value = now;

      // ray hover / polaroids / ornaments / surface
      updateRaycastHover();
      updatePolaroids(dt, now);
      updateOrnaments(dt, now);
      updateSurface(now);

      noHandFallback(performance.now());

      // âœ… å·¦å³æ»‘åŠ¨ï¼šé€Ÿåº¦ç§¯åˆ† + é™åˆ¶
      orbitInput.yawVel = damp(orbitInput.yawVel, orbitInput.targetYawVel, 10.0, dt);
      cameraState.targetYaw += orbitInput.yawVel * dt;

      if (cameraState.targetYaw > Math.PI) cameraState.targetYaw -= Math.PI * 2;
      if (cameraState.targetYaw < -Math.PI) cameraState.targetYaw += Math.PI * 2;

      cameraState.targetRadius = 20;

      applyCamera(dt);

      // âœ… å…³é”®æ–°å¢ï¼špinch æ”¾å¤§å•å¼ ç…§ç‰‡æ—¶ï¼Œåœæ­¢æ•´ä½“æ—‹è½¬
      const zoomingSingle =
        handState.hasHand &&
        handState.pinch > 0.28 &&
        (handState.hoverIndex >= 0 || (handState.detailMode && handState.selectedIndex >= 0));

      if (!zoomingSingle) {
        rootSpin += 0.0022;     // åŸæ¥çš„æ•´ä½“æ—‹è½¬é€Ÿåº¦
      }
      root.rotation.y = rootSpin;
      root.position.y = Math.sin(now * 0.7) * 0.03;

      debugEl.textContent =
        `hand: ${handState.hasHand} | mode: ${mode === MODE.CHAOS ? "CHAOS" : "FORMED"} | mix: ${mix.toFixed(2)}\n` +
        `radius: ${cameraState.radius.toFixed(1)} | yaw: ${cameraState.yaw.toFixed(2)} | yawVel: ${orbitInput.yawVel.toFixed(2)}\n` +
        `open: ${handState.open} | fist: ${handState.fist} | pinch: ${handState.pinch.toFixed(2)}\n` +
        `hover: ${handState.hoverIndex} | detail: ${handState.detailMode} | selected: ${handState.selectedIndex}\n` +
        `freezeSpin: ${zoomingSingle}`;

      renderer.render(scene, camera);
    }

    /*************************************************************
     * 13) resize
     *************************************************************/
    window.addEventListener("resize", () => {
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
    });

    /*************************************************************
     * 14) init
     *************************************************************/
    cameraState.radius = 20;
    cameraState.targetRadius = 20;
    cameraState.yaw = 0;
    cameraState.targetYaw = 0;
    applyCamera(0.016);

    statusEl.textContent = "åŠ è½½ assets ç…§ç‰‡ä¸­â€¦";
    await loadPolaroidsAuto();

    statusEl.textContent = "å·²åŠ è½½åœºæ™¯ï¼ˆç‚¹å‡»å¼€å§‹ä½“éªŒå¼€å¯æ‘„åƒå¤´ï¼‰";
    animate();
  </script>
</body>
</html>
