<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grand Luxury Interactive Christmas Tree (Single HTML)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#05080f; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",sans-serif; }
    #ui{
      position:fixed; left:12px; top:12px; z-index:20;
      color:#fff; background:rgba(0,0,0,.28); backdrop-filter: blur(8px);
      padding:10px 12px; border-radius:14px; user-select:none;
      max-width:560px; line-height:1.35;
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #ui .title{ font-size:14px; font-weight:600; letter-spacing:.2px; }
    #ui .sub{ margin-top:6px; font-size:12px; opacity:.85; }
    #ui .row{ margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #startBtn, #togglePanel{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 12px; border-radius:12px;
      font-size:13px; cursor:pointer;
    }
    #startBtn:hover, #togglePanel:hover { background:rgba(255,255,255,.12); }
    #startBtn:disabled{ opacity:.55; cursor:not-allowed; }
    #status{ margin-top:8px; font-size:12px; opacity:.85; white-space:pre-line; }

    #hint{
      position:fixed; left:12px; bottom:12px; z-index:20;
      color:rgba(255,255,255,.86);
      background:rgba(0,0,0,.26); backdrop-filter: blur(8px);
      padding:10px 12px; border-radius:14px;
      border:1px solid rgba(255,255,255,.06);
      max-width:620px; font-size:12px; white-space:pre-line;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    #err{
      position:fixed; right:12px; top:12px; z-index:30;
      display:none; max-width:560px; white-space:pre-wrap;
      color:#ffd7d7; background:rgba(80,0,0,.45);
      padding:10px 12px; border-radius:14px; font-size:12px;
      border:1px solid rgba(255,255,255,.08);
    }

    /* è§†é¢‘é¢æ¿ */
    #panel{
      position:fixed; right:12px; top:12px; z-index:25;
      width:320px;
      border-radius:16px;
      overflow:hidden;
      background:rgba(0,0,0,.30);
      backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      display:block;
    }
    #panelHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding:8px 10px;
      color:rgba(255,255,255,.90);
      font-size:12px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    #panelBody{ position:relative; width:100%; aspect-ratio: 16 / 9; background:#000; }
    #video{
      position:absolute; inset:0;
      width:100%; height:100%; object-fit:cover;
      transform: scaleX(-1); /* é•œåƒæ›´ç¬¦åˆç›´è§‰ */
    }
    #overlayCanvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    #panelFooter{
      padding:8px 10px;
      font-size:11px;
      color:rgba(255,255,255,.70);
      border-top:1px solid rgba(255,255,255,.08);
      white-space:pre-line;
    }
  </style>
</head>
<body>

  <div id="ui">
    <div class="title">Grand Luxury Interactive Christmas Treeï¼ˆå•æ–‡ä»¶ç¨³ç‰ˆï¼‰</div>
    <div class="sub">
      å¥¢åï¼šæ·±ç¥–æ¯ç»¿ + é‡‘è‰²é«˜å…‰ï¼ˆä¼ªè¾‰å…‰ï¼šshader + additive + fogï¼‰
      <br/>ç…§ç‰‡ï¼šè‡ªåŠ¨è¯»å– <code>assets/</code> å…¨éƒ¨å›¾ç‰‡ï¼ˆä»¥åæ–°å¢ä¸æ”¹ä»£ç ï¼‰
    </div>
    <div class="row">
      <button id="startBtn">â–¶ å¼€å§‹ä½“éªŒï¼ˆå¼€å¯æ‘„åƒå¤´ï¼‰</button>
      <button id="togglePanel">éšè—è§†é¢‘é¢æ¿</button>
    </div>
    <div id="status">çŠ¶æ€ï¼šæœªå¯åŠ¨ï¼ˆç²’å­æ ‘å·²åœ¨è¿è¡Œï¼‰</div>
  </div>

  <div id="hint">
âœ… æ‰‹åŠ¿
âœ‹ å¼ å¼€æ‰‹æŒï¼šCHAOSï¼ˆæ•£å¼€æ˜Ÿäº‘ï¼‰
âœŠ æ¡æ‹³ï¼šFORMEDï¼ˆèšåˆæˆæ ‘ï¼‰
ğŸ‘‰ æ‰‹å·¦å³ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
ğŸ¤ æ‹‡æŒ‡+é£ŸæŒ‡æåˆï¼šæ”¾å¤§å½“å‰æŒ‡å‘çš„æ‹ç«‹å¾—
ğŸ¤ æŒç»­æåˆ 300msï¼šè¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œå…¶å®ƒæ·¡å‡ºï¼‰
æ— æ‰‹ï¼šè‡ªåŠ¨å›åˆ° FORMED
  </div>

  <div id="panel">
    <div id="panelHeader">
      <span>Hand Preview</span>
      <span id="panelState" style="opacity:.75; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">OFF</span>
    </div>
    <div id="panelBody">
      <video id="video" playsinline muted></video>
      <canvas id="overlayCanvas"></canvas>
    </div>
    <div id="panelFooter" id="dbg">pinch=0.00 handX=0.00  mode=FORMED</div>
  </div>

  <div id="err"></div>

  <!-- âœ… æœ€ç¨³ï¼šMediaPipe ç”¨æ™®é€š scriptï¼ˆå…¨å±€ Hands / Cameraï¼‰ -->
  <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
  <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

  <!-- âœ… Three.js ä¹Ÿç”¨æ™®é€š scriptï¼ˆå…¨å±€ THREEï¼‰ -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  /*********************************************************
   *  0) é”™è¯¯æ˜¾ç¤ºï¼ˆé¿å…é»‘å±æ— æç¤ºï¼‰
   *********************************************************/
  const statusBox = document.getElementById("status");
  const errBox = document.getElementById("err");
  const panel = document.getElementById("panel");
  const panelState = document.getElementById("panelState");
  const panelFooter = document.getElementById("panelFooter");
  const startBtn = document.getElementById("startBtn");
  const togglePanelBtn = document.getElementById("togglePanel");
  const videoEl = document.getElementById("video");
  const overlayCanvas = document.getElementById("overlayCanvas");
  const overlayCtx = overlayCanvas.getContext("2d");

  function setStatus(s){ statusBox.textContent = "çŠ¶æ€ï¼š" + s; }
  function showError(s){ errBox.style.display = "block"; errBox.textContent = s; }

  window.addEventListener("error", (e) => showError("âŒ è¿è¡ŒæŠ¥é”™ï¼š\n" + (e?.message || e)));
  window.addEventListener("unhandledrejection", (e) => showError("âŒ Promise æŠ¥é”™ï¼š\n" + (e?.reason?.message || e?.reason || e)));

  togglePanelBtn.addEventListener("click", () => {
    const visible = panel.style.display !== "none";
    panel.style.display = visible ? "none" : "block";
    togglePanelBtn.textContent = visible ? "æ˜¾ç¤ºè§†é¢‘é¢æ¿" : "éšè—è§†é¢‘é¢æ¿";
  });

  /*********************************************************
   *  1) è‡ªåŠ¨è¯†åˆ« owner/repoï¼ˆé€‚é…ä½ çš„ GitHub Pagesï¼‰
   *     - https://<owner>.github.io/<repo>/
   *********************************************************/
  function inferGithubRepo() {
    const host = location.hostname; // probiozzp.github.io
    const owner = host.endsWith(".github.io") ? host.replace(".github.io","") : "probiozzp";
    // pathname: /christmas-tree/...
    const seg = location.pathname.split("/").filter(Boolean);
    const repo = seg.length ? seg[0] : "christmas-tree";
    return { owner, repo };
  }

  /*********************************************************
   *  2) Three.jsï¼šåœºæ™¯ / ç›¸æœº / æ¸²æŸ“å™¨
   *********************************************************/
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05080f);
  scene.fog = new THREE.Fog(0x05080f, 10, 35);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 200);
  camera.position.set(0, 4, 20);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(devicePixelRatio || 1);
  document.body.appendChild(renderer.domElement);

  // å¥¢åå…‰ï¼šé‡‘è‰²ä¸»æ‰“å…‰ + å†·è‰²è¾…å…‰
  scene.add(new THREE.AmbientLight(0xffffff, 0.18));

  const keyLight = new THREE.DirectionalLight(0xffd27d, 2.2);
  keyLight.position.set(7, 12, 8);
  scene.add(keyLight);

  const rimLight = new THREE.DirectionalLight(0x9bdcff, 0.45);
  rimLight.position.set(-8, 10, -10);
  scene.add(rimLight);

  /*********************************************************
   *  3) çŠ¶æ€æœº & å¹³æ»‘å‚æ•°
   *********************************************************/
  let mode = "FORMED";       // FORMED / CHAOS
  let targetMix = 0;         // 0=FORMED, 1=CHAOS
  let mix = 0;

  // è§†è§’ yawï¼ˆæ‰‹å·¦å³ç§»åŠ¨æ§åˆ¶ï¼‰
  let targetYaw = 0;
  let yaw = 0;

  // pinch & æ‰‹çŠ¶æ€
  let pinch = 0;             // 0..1
  let hasHand = false;
  let lastHandSeenAt = 0;

  // è¯¦æƒ…æ¨¡å¼ï¼ˆé•¿æåˆï¼‰
  let detailMode = false;
  let pinchStartAt = 0;

  /*********************************************************
   *  4) è±ªåç²’å­é’ˆå¶ï¼ˆPoints + ShaderMaterialï¼‰
   *     - additive + è½¯ç‚¹ + é«˜åº¦æ¸å˜ï¼ˆç¥–æ¯ç»¿->é‡‘ï¼‰
   *********************************************************/
  const COUNT = 6800;
  const H = 6.2;
  const R = 3.2;

  function makeConeTarget(i) {
    const y = Math.random() * H;
    const radius = (1 - y / H) * R;
    const a = Math.random() * Math.PI * 2;
    const x = Math.cos(a) * radius;
    const z = Math.sin(a) * radius;
    return [x, y, z];
  }
  function makeChaosPos() {
    const t = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const rr = 8 + Math.random() * 10;
    const x = rr * Math.sqrt(1 - u*u) * Math.cos(t);
    const y = 2 + rr * u * 0.35;
    const z = rr * Math.sqrt(1 - u*u) * Math.sin(t);
    return [x,y,z];
  }

  const foliageGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(COUNT*3);
  const aTarget = new Float32Array(COUNT*3);
  const aChaos = new Float32Array(COUNT*3);
  const aSeed = new Float32Array(COUNT);

  for (let i=0;i<COUNT;i++){
    const t = makeConeTarget(i);
    const c = makeChaosPos();
    aTarget.set(t, i*3);
    aChaos.set(c, i*3);
    pos.set(t, i*3);
    aSeed[i] = Math.random();
  }
  foliageGeom.setAttribute("position", new THREE.BufferAttribute(pos,3));
  foliageGeom.setAttribute("aTarget", new THREE.BufferAttribute(aTarget,3));
  foliageGeom.setAttribute("aChaos", new THREE.BufferAttribute(aChaos,3));
  foliageGeom.setAttribute("aSeed", new THREE.BufferAttribute(aSeed,1));

  const foliageMat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uMix: { value: 0 },
      uEmerald: { value: new THREE.Color("#0b3d2e") }, // æ·±ç¥–æ¯ç»¿
      uGold: { value: new THREE.Color("#ffd27d") }     // é«˜å…‰é‡‘
    },
    vertexShader: `
      attribute vec3 aTarget;
      attribute vec3 aChaos;
      attribute float aSeed;

      uniform float uTime;
      uniform float uMix;

      varying float vGlow;
      varying float vAlpha;

      float hash(float n){ return fract(sin(n)*43758.5453123); }

      void main(){
        vec3 p = mix(aTarget, aChaos, uMix);

        // â€œä¼ªè¾‰å…‰â€è¾…åŠ©ï¼šæ¼‚æµ® + å‘¼å¸ï¼ˆä¸è¿‡åº¦æŠ–ï¼‰
        float n = hash(aSeed*17.0);
        p.y += sin(uTime*1.2 + aSeed*6.2831) * 0.03 * (0.3 + 0.7*n);
        p.x += sin(uTime*0.9 + aSeed*3.0) * 0.01;
        p.z += cos(uTime*0.9 + aSeed*3.0) * 0.01;

        // é¡¶éƒ¨æ›´äº®
        vGlow = smoothstep(2.2, 6.2, p.y);

        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mv;

        float size = mix(6.0, 13.0, vGlow);    // é¡¶éƒ¨æ›´â€œè´µâ€
        gl_PointSize = size * (1.0 / -mv.z);

        // è¿œå¤„æ›´é€æ˜ï¼Œé¿å…ç³Šæˆä¸€å¨
        vAlpha = clamp(1.0 - (-mv.z / 40.0), 0.18, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;

      uniform vec3 uEmerald;
      uniform vec3 uGold;

      varying float vGlow;
      varying float vAlpha;

      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);

        // è½¯åœ†ç‚¹ï¼šä¸­å¿ƒäº®ã€è¾¹ç¼˜æŸ”
        float core = smoothstep(0.35, 0.0, d);
        float alpha = smoothstep(0.5, 0.18, d);

        // é¢œè‰²ï¼šç¥–æ¯ç»¿ä¸ºä¸»ï¼Œé¡¶éƒ¨åé‡‘
        vec3 col = mix(uEmerald, uGold, vGlow*0.92);

        // â€œé‡‘è‰²é«˜å…‰â€è¾¹ç¼˜åŠ ä¸€ç‚¹ç‚¹
        col += uGold * core * 0.18;

        gl_FragColor = vec4(col, alpha * vAlpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  const foliage = new THREE.Points(foliageGeom, foliageMat);
  scene.add(foliage);

  // æ ‘é¡¶æ˜Ÿï¼šæ›´â€œå¥¢åâ€çš„é‡‘è‰²å‘å…‰
  const star = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.35, 1),
    new THREE.MeshBasicMaterial({ color: 0xfff3c4 })
  );
  star.position.set(0, H + 0.45, 0);
  scene.add(star);

  /*********************************************************
   *  5) ç¯ä¸²ç‚¹ï¼ˆInstancedMeshï¼Œå°å‘å…‰ç‚¹ï¼Œé…åˆ additive çœ‹èµ·æ¥åƒ Bloomï¼‰
   *********************************************************/
  const lightCount = 180;
  const lightGeom = new THREE.SphereGeometry(0.06, 10, 10);
  const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const lightInst = new THREE.InstancedMesh(lightGeom, lightMat, lightCount);
  lightInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  scene.add(lightInst);

  const lightTarget = [];
  const lightChaos = [];
  const lightSeed = [];
  for (let i=0;i<lightCount;i++){
    // æ²¿æ ‘è¡¨é¢ç»•åœˆï¼ˆèºæ—‹ç¯å¸¦ï¼‰
    const y = Math.random()*H*0.92 + 0.1;
    const baseR = (1 - y/H)*R + 0.45;
    const a = (y/H)*Math.PI*8 + Math.random()*0.8; // å¤šç»•å‡ åœˆæ›´â€œè±ªåâ€
    const x = Math.cos(a)*baseR;
    const z = Math.sin(a)*baseR;
    lightTarget.push(new THREE.Vector3(x,y,z));

    const c = makeChaosPos();
    lightChaos.push(new THREE.Vector3(c[0],c[1],c[2]));
    lightSeed.push(Math.random());
  }

  /*********************************************************
   *  6) æ‹ç«‹å¾—ç…§ç‰‡ï¼ˆè‡ªåŠ¨è¯»å– assets/ å…¨éƒ¨å›¾ç‰‡ï¼‰
   *     - æ¯å¼ ç…§ç‰‡ï¼šç™½è‰²åšè¾¹æ¡† + åº•éƒ¨ç•™ç™½ + å¾®åå…‰
   *********************************************************/
  const photoGroup = new THREE.Group();
  scene.add(photoGroup);

  const photoCards = []; // {id, group, frameMat, photoMat, target, chaos, seed}
  let hoveredCard = null;

  const texLoader = new THREE.TextureLoader();

  function createPolaroidCard(texture){
    // æ‹ç«‹å¾—å‚æ•°
    const cardW = 1.10;
    const cardH = 1.35;
    const thickness = 0.06;
    const photoW = 0.95;
    const photoH = 0.80;
    const bottomH = 0.30;

    const g = new THREE.Group();

    // ç™½è‰²ç›¸çº¸èƒŒæ¿ï¼ˆç•¥åå…‰ï¼‰
    const frameMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#ffffff"),
      roughness: 0.35,
      metalness: 0.05,
      transparent: true,
      opacity: 1
    });
    const frame = new THREE.Mesh(
      new THREE.BoxGeometry(cardW, cardH, thickness),
      frameMat
    );
    g.add(frame);

    // ç…§ç‰‡åŒºåŸŸï¼ˆå¾®åå…‰ï¼‰
    texture.colorSpace = THREE.SRGBColorSpace;
    const photoMat = new THREE.MeshStandardMaterial({
      map: texture,
      roughness: 0.25,
      metalness: 0.05,
      transparent: true,
      opacity: 1
    });
    const photo = new THREE.Mesh(
      new THREE.PlaneGeometry(photoW, photoH),
      photoMat
    );
    photo.position.set(0, 0.16, thickness*0.55);
    g.add(photo);

    // åº•éƒ¨ç•™ç™½
    const bottom = new THREE.Mesh(
      new THREE.PlaneGeometry(photoW, bottomH),
      new THREE.MeshStandardMaterial({ color:"#f4f4f4", roughness:0.75, metalness:0.0, transparent:true, opacity:1 })
    );
    bottom.position.set(0, -0.43, thickness*0.55);
    g.add(bottom);

    // å°â€œå¤¹å­â€ï¼ˆå¢åŠ çœŸå®æ„Ÿï¼‰
    const clip = new THREE.Mesh(
      new THREE.BoxGeometry(0.12, 0.10, 0.04),
      new THREE.MeshStandardMaterial({ color:"#ffd27d", roughness:0.25, metalness:0.55 })
    );
    clip.position.set(0, cardH*0.53, thickness*0.45);
    g.add(clip);

    g.userData = { frameMat, photoMat, bottomMat: bottom.material };
    return g;
  }

  function placeTargetOnTree(){
    const y = Math.random()*H*0.85 + 0.55;
    const r = (1 - y/H)*R + 0.75;
    const a = Math.random()*Math.PI*2;
    return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
  }

  async function loadAssetsImagesAuto(){
    const { owner, repo } = inferGithubRepo();
    const api = `https://api.github.com/repos/${owner}/${repo}/contents/assets`;

    try{
      const res = await fetch(api, { cache:"no-store" });
      if(!res.ok){
        setStatus(`assets åˆ—è¡¨è¯»å–å¤±è´¥ï¼ˆHTTP ${res.status}ï¼‰ã€‚è¯·ç¡®è®¤ä»“åº“æ ¹ç›®å½•æœ‰ assets/ æ–‡ä»¶å¤¹ã€‚`);
        return;
      }
      const items = await res.json();
      const exts = [".png",".jpg",".jpeg",".webp",".gif"];
      const files = items
        .filter(it => it.type==="file" && exts.some(ext => it.name.toLowerCase().endsWith(ext)))
        .map(it => it.name);

      if(files.length === 0){
        setStatus("assets/ æ²¡æ‰¾åˆ°å›¾ç‰‡ï¼ˆè¯·ä¸Šä¼ å›¾ç‰‡åˆ° assets/ï¼‰");
        return;
      }

      setStatus(`å·²å‘ç° assets å›¾ç‰‡ ${files.length} å¼ ï¼ŒåŠ è½½ä¸­â€¦`);

      // ç”¨åŒåŸŸç›¸å¯¹è·¯å¾„åŠ è½½ï¼Œé¿å…çº¹ç†è·¨åŸŸé—®é¢˜
      for (let i=0;i<files.length;i++){
        const name = files[i];
        const url = `./assets/${encodeURIComponent(name)}`;
        texLoader.load(url, (tex)=>{
          const group = createPolaroidCard(tex);

          // dual-position
          const target = placeTargetOnTree();
          const c = makeChaosPos();
          const chaos = new THREE.Vector3(c[0],c[1],c[2]);

          // åˆå§‹æ‘†æ”¾åˆ° target
          group.position.copy(target);

          // æœå‘å¤–ä¾§ä¸€ç‚¹
          group.lookAt(0, target.y, 0);
          group.rotateZ((Math.random()*2-1) * 0.25);

          photoGroup.add(group);

          photoCards.push({
            id: "polaroid-"+name,
            group,
            target,
            chaos,
            seed: Math.random(),
            url
          });

          setStatus(`ç…§ç‰‡å·²åŠ è½½ï¼š${photoCards.length}/${files.length}ï¼ˆå¯ç‚¹å‡»å¼€å§‹ä½“éªŒå¼€å¯æ‘„åƒå¤´ï¼‰`);
        }, undefined, ()=>{
          console.warn("å›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", url);
        });
      }

    }catch(e){
      console.warn(e);
      setStatus("assets åˆ—è¡¨è¯»å–å¤±è´¥ï¼ˆç½‘ç»œ/æƒé™é—®é¢˜ï¼‰");
    }
  }
  loadAssetsImagesAuto();

  /*********************************************************
   *  7) Raycasterï¼šç”¨é£ŸæŒ‡æŒ‡å°–å½“å…‰æ ‡ hover æ‹ç«‹å¾—
   *********************************************************/
  const raycaster = new THREE.Raycaster();
  let lastIndexNDC = null; // {x,y}

  function updateHover(){
    if (!lastIndexNDC || photoCards.length===0){
      hoveredCard = null;
      return;
    }
    raycaster.setFromCamera(lastIndexNDC, camera);
    const objects = photoCards.map(c => c.group);
    const hits = raycaster.intersectObjects(objects, true);

    if (hits.length){
      // æ‰¾åˆ°å‘½ä¸­çš„é¡¶å±‚ card group
      let obj = hits[0].object;
      while (obj && obj.parent && obj.parent !== photoGroup){
        obj = obj.parent;
      }
      hoveredCard = photoCards.find(c => c.group === obj) || null;
    }else{
      hoveredCard = null;
    }
  }

  /*********************************************************
   *  8) MediaPipe Handsï¼šç‚¹å‡» Start æ‰è¯·æ±‚æƒé™ï¼ˆæœ€ç¨³ï¼‰
   *********************************************************/
  let started = false;
  let cameraMP = null;
  let hands = null;

  // ç”»æ‰‹éƒ¨éª¨æ¶
  function drawLandmarks(lm){
    // resize canvas to css size
    const w = overlayCanvas.clientWidth;
    const h = overlayCanvas.clientHeight;
    const dpr = devicePixelRatio || 1;
    if (overlayCanvas.width !== Math.floor(w*dpr) || overlayCanvas.height !== Math.floor(h*dpr)){
      overlayCanvas.width = Math.floor(w*dpr);
      overlayCanvas.height = Math.floor(h*dpr);
      overlayCtx.setTransform(dpr,0,0,dpr,0,0);
    }
    overlayCtx.clearRect(0,0,w,h);
    if(!lm) return;

    // ç‚¹
    overlayCtx.fillStyle = "rgba(255,210,125,0.95)";
    for (const p of lm){
      overlayCtx.beginPath();
      overlayCtx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2);
      overlayCtx.fill();
    }

    // è¾¹
    const edges = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20]
    ];
    overlayCtx.strokeStyle = "rgba(255,255,255,0.55)";
    overlayCtx.lineWidth = 2;
    for (const [a,b] of edges){
      const pa = lm[a], pb = lm[b];
      overlayCtx.beginPath();
      overlayCtx.moveTo(pa.x*w, pa.y*h);
      overlayCtx.lineTo(pb.x*w, pb.y*h);
      overlayCtx.stroke();
    }
  }

  // æ‰‹åŠ¿è®¡ç®—ï¼špinch + open/fist + handX
  function computeGestures(lm){
    const thumbTip = lm[4];
    const indexTip = lm[8];
    const palm = lm[0];

    const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
    const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
    let p = (PINCH_MAX - d) / (PINCH_MAX - PINCH_MIN);
    p = Math.max(0, Math.min(1, p));

    // æ‰‹å·¦å³ï¼šç”¨ indexTip.x æ˜ å°„ [-1,1]
    const hx = (indexTip.x - 0.5) * 2;

    // open/fistï¼šæŒ‡å°–åˆ°æŒå¿ƒè·ç¦»å’Œ
    const tips = [lm[8], lm[12], lm[16], lm[20]];
    const sumDist = tips.reduce((acc, pt)=> acc + Math.hypot(pt.x - palm.x, pt.y - palm.y), 0);

    return { pinch:p, handX:hx, sumDist, indexTip };
  }

  // EMA å¹³æ»‘
  let smoothPinch = 0;
  let smoothHandX = 0;

  async function startExperience(){
    if (started) return;
    started = true;
    startBtn.disabled = true;

    setStatus("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™â€¦ï¼ˆè¯·å…è®¸ï¼‰");
    panelState.textContent = "REQ";

    try{
      hands = new Hands({
        locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results)=>{
        const lm = results?.multiHandLandmarks?.[0];
        if(!lm){
          hasHand = false;
          drawLandmarks(null);
          return;
        }

        hasHand = true;
        lastHandSeenAt = performance.now();

        // ç»˜åˆ¶éª¨æ¶
        drawLandmarks(lm);

        const g = computeGestures(lm);

        // å¹³æ»‘
        const alpha = 0.18;
        smoothPinch = smoothPinch + (g.pinch - smoothPinch) * alpha;
        smoothHandX = smoothHandX + (g.handX - smoothHandX) * alpha;
        pinch = smoothPinch;

        // ä½œä¸ºâ€œå…‰æ ‡â€çš„é£ŸæŒ‡ tip NDCï¼ˆæ³¨æ„ y è½´åå‘ï¼‰
        lastIndexNDC = { x: g.indexTip.x*2 - 1, y: -(g.indexTip.y*2 - 1) };

        // çŠ¶æ€æœºï¼šå¼€æŒ/æ¡æ‹³ï¼ˆæ»å›é˜ˆå€¼ï¼‰
        const OPEN_T = 0.55, FIST_T = 0.38;
        if (g.sumDist > OPEN_T) { mode = "CHAOS"; targetMix = 1; }
        else if (g.sumDist < FIST_T) { mode = "FORMED"; targetMix = 0; }

        // è§†è§’æ—‹è½¬
        targetYaw = THREE.MathUtils.clamp(smoothHandX * 0.55, -0.9, 0.9);

        // è¯¦æƒ…æ¨¡å¼ï¼šå¼º pinch + hoverï¼ŒæŒç»­ 300ms
        if (pinch > 0.8 && hoveredCard){
          if (!pinchStartAt) pinchStartAt = performance.now();
          if (performance.now() - pinchStartAt > 300) detailMode = true;
        }else{
          pinchStartAt = 0;
          detailMode = false;
        }
      });

      cameraMP = new Camera(videoEl, {
        onFrame: async () => {
          await hands.send({ image: videoEl });
        },
        width: 640,
        height: 480
      });

      await cameraMP.start();

      setStatus("æ‘„åƒå¤´å·²å¼€å¯ âœ…ï¼ˆå¼€å§‹æ‰‹åŠ¿äº¤äº’ï¼‰");
      panelState.textContent = "ON";

    }catch(e){
      started = false;
      startBtn.disabled = false;
      setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ âŒ");
      panelState.textContent = "ERR";
      const msg = e?.name ? `${e.name}: ${e.message}` : String(e);
      showError(
        "âŒ æ‘„åƒå¤´æ— æ³•å¯åŠ¨ã€‚\n\n" +
        "å¸¸è§åŸå› ï¼š\n" +
        "1) ä½ æ›¾ç»å¯¹è¯¥ç«™ç‚¹ç‚¹è¿‡â€œé˜»æ­¢æ‘„åƒå¤´â€ï¼ˆChrome ä»¥åä¸ä¼šå¼¹çª—ï¼‰\n" +
        "2) ç³»ç»Ÿè®¾ç½®é‡Œæœªå…è®¸æµè§ˆå™¨ä½¿ç”¨æ‘„åƒå¤´\n" +
        "3) æ‘„åƒå¤´è¢«å…¶ä»–ç¨‹åºå ç”¨\n\n" +
        "é”™è¯¯ä¿¡æ¯ï¼š\n" + msg + "\n\n" +
        "è§£å†³ï¼šç‚¹åœ°å€æ å·¦ä¾§å°é” â†’ ç½‘ç«™è®¾ç½® â†’ æ‘„åƒå¤´ â†’ å…è®¸ï¼Œç„¶ååˆ·æ–°å†ç‚¹å¼€å§‹ä½“éªŒã€‚"
      );
    }
  }
  startBtn.addEventListener("click", startExperience);

  /*********************************************************
   *  9) åŠ¨ç”»å¾ªç¯ï¼šmix æ’å€¼ã€è±ªåæ„ŸåŠ¨ç”»ã€ç…§ç‰‡äº¤äº’
   *********************************************************/
  const dummy = new THREE.Object3D();

  function updateLights(t){
    // ç¯ç‚¹ï¼šåœ¨ç›®æ ‡/æ··æ²Œä¹‹é—´æ’å€¼ï¼ŒåŒæ—¶é—ªçƒ
    for (let i=0;i<lightCount;i++){
      const p = new THREE.Vector3().lerpVectors(lightTarget[i], lightChaos[i], mix);
      p.y += Math.sin(t*2.0 + lightSeed[i]*10) * 0.05;

      dummy.position.copy(p);
      const s = 1 + Math.sin(t*3.0 + lightSeed[i]*20) * 0.15;
      dummy.scale.setScalar(s);
      dummy.updateMatrix();
      lightInst.setMatrixAt(i, dummy.matrix);
    }
    lightInst.instanceMatrix.needsUpdate = true;

    // ç¯é¢œè‰²å¶å°”åé‡‘ï¼ˆæ›´â€œTrump-likeâ€ï¼‰
    const tw = (Math.sin(t*1.8)*0.5+0.5);
    lightMat.color.setHSL(0.14, 0.25, 0.85 + tw*0.08);
  }

  function updatePolaroids(t){
    updateHover();

    for (const c of photoCards){
      const g = c.group;

      // dual position
      const p = new THREE.Vector3().lerpVectors(c.target, c.chaos, mix);

      // åƒæŒ‚ç€çš„æ‘†åŠ¨
      const sway = Math.sin(t*0.9 + c.seed*10) * 0.08;
      const tilt = Math.cos(t*0.7 + c.seed*10) * 0.06;

      const isHover = hoveredCard && hoveredCard.group === g;

      if (detailMode && isHover){
        // è¯¦æƒ…æ¨¡å¼ï¼šå±…ä¸­
        g.position.lerp(new THREE.Vector3(0, 3.8, 6.2), 0.10);
        g.rotation.x = THREE.MathUtils.lerp(g.rotation.x, 0, 0.10);
        g.rotation.y = THREE.MathUtils.lerp(g.rotation.y, 0, 0.10);
        g.rotation.z = THREE.MathUtils.lerp(g.rotation.z, 0, 0.10);
      } else {
        g.position.lerp(p, 0.20);

        // æœå¤–ä¾§
        g.lookAt(0, g.position.y, 0);
        g.rotateZ(sway * 0.6);

        g.rotation.x += tilt*0.05;
        g.rotation.y += sway*0.03;
      }

      // hover + pinch ç¼©æ”¾
      const targetScale = isHover ? (1 + pinch*1.5) : 1;
      g.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.18);

      // æ·¡å‡ºå…¶ä»–
      const mats = g.userData;
      const targetOpacity = (detailMode && !isHover) ? 0.18 : 1.0;
      if (mats?.frameMat) mats.frameMat.opacity = THREE.MathUtils.lerp(mats.frameMat.opacity, targetOpacity, 0.12);
      if (mats?.photoMat) mats.photoMat.opacity = THREE.MathUtils.lerp(mats.photoMat.opacity, targetOpacity, 0.12);
      if (mats?.bottomMat) mats.bottomMat.opacity = THREE.MathUtils.lerp(mats.bottomMat.opacity, targetOpacity, 0.12);
    }
  }

  function animate(){
    requestAnimationFrame(animate);
    const t = performance.now()*0.001;

    // æ— æ‰‹å›é€€ï¼ˆå³ä½¿æ‘„åƒå¤´å¼€ç€ï¼‰
    if (started && hasHand && (performance.now() - lastHandSeenAt > 1200)){
      hasHand = false;
      pinch = 0;
      lastIndexNDC = null;
      detailMode = false;
      mode = "FORMED"; targetMix = 0;
      targetYaw = 0;
      panelState.textContent = "ON";
    }

    // mix å¹³æ»‘æ’å€¼ï¼ˆæ›´ä¸æ»‘ï¼‰
    const speed = 2.2;
    const a = 1 - Math.exp(-speed * 0.016);
    mix = mix + (targetMix - mix) * a;

    // yaw å¹³æ»‘
    yaw = yaw + (targetYaw - yaw) * 0.10;

    // ç›¸æœºè½»å¾®æ¼‚æµ®ï¼ˆå¥¢åæ„Ÿï¼‰
    const camY = 4 + Math.sin(t*0.6)*0.15;
    camera.position.lerp(new THREE.Vector3(0, camY, 20), 0.08);
    camera.rotation.y = yaw;
    camera.lookAt(0, 4, 0);

    // ç²’å­æ›´æ–°
    foliageMat.uniforms.uTime.value = t;
    foliageMat.uniforms.uMix.value = mix;

    // æ ‘æ•´ä½“è½»å¾®è‡ªè½¬ï¼ˆå³ä½¿æ— æ‰‹ä¹Ÿä¸æ­»æ¿ï¼‰
    foliage.rotation.y += 0.002;
    photoGroup.rotation.y = foliage.rotation.y;
    lightInst.rotation.y = foliage.rotation.y;

    // æ˜Ÿæ˜Ÿå‘¼å¸
    const s = 1 + Math.sin(t*2.2)*0.07;
    star.scale.setScalar(s);

    // æ›´æ–°ç¯ç‚¹/ç…§ç‰‡
    updateLights(t);
    updatePolaroids(t);

    // UI è°ƒè¯•
    panelFooter.textContent =
      `pinch=${pinch.toFixed(2)}  handX=${(yaw/0.55).toFixed(2)}  mode=${mode}  mix=${mix.toFixed(2)}`
      + (detailMode ? "  DETAIL" : "");

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  </script>
</body>
</html>
