<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>3D æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #05080f; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; }
    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      color: #fff;
      user-select: none;
      font-size: 14px;
      line-height: 1.35;
      background: rgba(0,0,0,0.25);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 420px;
    }
    #hint {
      position: fixed;
      bottom: 12px;
      left: 12px;
      z-index: 10;
      color: rgba(255,255,255,0.85);
      font-size: 12px;
      background: rgba(0,0,0,0.25);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 460px;
      white-space: pre-line;
    }
    #startBtn {
      margin-top: 10px;
      appearance: none;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    #startBtn:hover { background: rgba(255,255,255,0.12); }
    #startBtn:disabled { opacity: 0.6; cursor: not-allowed; }

    #status {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.85;
      white-space: pre-line;
    }

    #err {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 20;
      color: #ffd7d7;
      font-size: 12px;
      background: rgba(80,0,0,0.45);
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 520px;
      white-space: pre-wrap;
      display: none;
    }
  </style>
</head>
<body>

<div id="ui">
  ğŸ„ 3D æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘ï¼ˆé¢„ç½®ç…§ç‰‡æŒ‚ä»¶ï¼‰
  <div style="margin-top:6px;opacity:.85">
    é¢„ç½®å›¾ç‰‡è·¯å¾„ï¼š<code>./assets/1.jpg</code> / <code>2.jpg</code> / <code>3.jpg</code>
  </div>
  <button id="startBtn">â–¶ å¼€å§‹ä½“éªŒï¼ˆå¼€å¯æ‘„åƒå¤´ï¼‰</button>
  <div id="status">çŠ¶æ€ï¼šæœªå¯åŠ¨æ‘„åƒå¤´</div>
</div>

<div id="hint">
âœ… æ“ä½œæç¤ºï¼ˆå¼€å§‹ä½“éªŒåï¼‰
ğŸ‘‰ é£ŸæŒ‡æŒ‡å‘ï¼šé€‰ä¸­ç…§ç‰‡ï¼ˆhoverï¼‰
ğŸ¤ æ‹‡æŒ‡+é£ŸæŒ‡æåˆï¼šæ”¾å¤§é€‰ä¸­ç…§ç‰‡ï¼ˆæåˆè¶Šç´§æ”¾å¤§è¶Šå¤§ï¼‰
âœ‹ å¼ å¼€æ‰‹æŒï¼šç²’å­æ•£å¼€æˆæ˜Ÿäº‘
âœŠ æ¡æ‹³ï¼šç²’å­é‡æ–°èšåˆæˆåœ£è¯æ ‘
ğŸ¤ æŒç»­æåˆ 300msï¼šè¿›å…¥è¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰
æ¾å¼€æåˆ / æ— æ‰‹ï¼šè‡ªåŠ¨é€€å‡º
</div>

<div id="err"></div>

<!-- éšè—è§†é¢‘æµå®¹å™¨ï¼ˆMediaPipe éœ€è¦ï¼‰ -->
<video id="video" style="display:none;" playsinline></video>

<script type="module">
/* ======================================================
 *  ä¾èµ–å¼•å…¥ï¼ˆunpkg é€šå¸¸æ¯” jsdelivr æ›´ç¨³ï¼‰
 * ====================================================== */
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { Hands } from "https://unpkg.com/@mediapipe/hands/hands.js";
import { Camera } from "https://unpkg.com/@mediapipe/camera_utils/camera_utils.js";

/* ======================================================
 *  é”™è¯¯æ˜¾ç¤ºï¼ˆé¿å…é»‘å±æ— æç¤ºï¼‰
 * ====================================================== */
const errBox = document.getElementById("err");
const statusBox = document.getElementById("status");
function setStatus(text) { statusBox.textContent = "çŠ¶æ€ï¼š" + text; }
function showError(text) {
  errBox.style.display = "block";
  errBox.textContent = text;
}
window.addEventListener("error", (e) => showError("âŒ è¿è¡ŒæŠ¥é”™ï¼š\n" + (e?.message || e)));
window.addEventListener("unhandledrejection", (e) => showError("âŒ Promise æŠ¥é”™ï¼š\n" + (e?.reason?.message || e?.reason || e)));

/* ======================================================
 *  å…¨å±€å‚æ•°ï¼ˆå¯è°ƒï¼‰
 * ====================================================== */
const PARAMS = {
  TREE_HEIGHT: 6,
  TREE_RADIUS: 3,
  PARTICLE_COUNT: 4500,

  PINCH_MIN: 0.02,
  PINCH_MAX: 0.12,
  DETAIL_HOLD_MS: 300,

  NO_HAND_TIMEOUT_MS: 1200,
  DEFAULT_ROTATE_SPEED: 0.002,
};

/* ======================================================
 *  Three.js åœºæ™¯
 * ====================================================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x05080f, 8, 22);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 3, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.2));

/* ======================================================
 *  ç²’å­ï¼šæ ‘å½¢ <-> æ˜Ÿäº‘ æ··åˆ
 * ====================================================== */
const positions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const cloudPositions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);

for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
  // æ ‘å½¢é”¥ä½“
  const y = Math.random() * PARAMS.TREE_HEIGHT;
  const radius = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS;
  const angle = Math.random() * Math.PI * 2;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);

  // æ˜Ÿäº‘äº‘å›¢
  const t = Math.random() * Math.PI * 2;
  const u = Math.random() * 2 - 1;
  const rr = 4 + Math.random() * 4;
  const cx = rr * Math.sqrt(1 - u*u) * Math.cos(t);
  const cy = 2 + rr * u * 0.35;
  const cz = rr * Math.sqrt(1 - u*u) * Math.sin(t);
  cloudPositions.set([cx, cy, cz], i * 3);
}

const geom = new THREE.BufferGeometry();
geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const colors = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const cGreen = new THREE.Color("#2cff9a");
const cGold  = new THREE.Color("#ffd27d");
const cWhite = new THREE.Color("#ffffff");
for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
  const r = Math.random();
  const c = r < 0.55 ? cGreen : (r < 0.85 ? cGold : cWhite);
  colors.set([c.r, c.g, c.b], i * 3);
}
geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const mat = new THREE.PointsMaterial({
  size: 0.06,
  transparent: true,
  opacity: 0.9,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  vertexColors: true
});

const treePoints = new THREE.Points(geom, mat);
scene.add(treePoints);

// æ ‘é¡¶æ˜Ÿæ˜Ÿ
const star = new THREE.Mesh(
  new THREE.SphereGeometry(0.26, 18, 18),
  new THREE.MeshBasicMaterial({ color: 0xffffcc })
);
star.position.set(0, PARAMS.TREE_HEIGHT + 0.3, 0);
scene.add(star);

/* ======================================================
 *  ç…§ç‰‡ç³»ç»Ÿï¼ˆä»…é¢„ç½®ï¼Œä¸æä¾›ç”¨æˆ·ä¸Šä¼ ï¼‰
 * ====================================================== */
const photoGroup = new THREE.Group();
scene.add(photoGroup);
const photoMeshes = [];

function placePhotoMesh(mesh) {
  const y = Math.random() * PARAMS.TREE_HEIGHT * 0.85 + 0.5;
  const r = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS + 0.6;
  const a = Math.random() * Math.PI * 2;
  mesh.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
  mesh.lookAt(0, y, 0);
}

function addPhotoFromTexture(texture) {
  texture.colorSpace = THREE.SRGBColorSpace;

  const geo = new THREE.PlaneGeometry(1, 1);
  const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1 });
  const mesh = new THREE.Mesh(geo, mat);

  placePhotoMesh(mesh);
  photoGroup.add(mesh);
  photoMeshes.push(mesh);
}

function addPhotoFromUrl(url) {
  const loader = new THREE.TextureLoader();
  loader.load(
    url,
    (tex) => addPhotoFromTexture(tex),
    undefined,
    () => {
      // é¢„ç½®å›¾ç‰‡æ‰¾ä¸åˆ°æ—¶ä¸è‡´å‘½ï¼Œä½†ä¼šæç¤º
      console.warn("é¢„ç½®å›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", url);
      setStatus("é¢„ç½®å›¾ç‰‡åŠ è½½å¤±è´¥ï¼ˆè¯·ç¡®è®¤ assets/1.jpg ç­‰å·²ä¸Šä¼ ï¼‰");
    }
  );
}

// é¢„ç½®å›¾ç‰‡åˆ—è¡¨ï¼šä½ å¯ä»¥å¢åˆ 
const defaultPhotos = ["./assets/1.jpg", "./assets/2.jpg", "./assets/3.jpg"];
defaultPhotos.forEach(addPhotoFromUrl);

/* ======================================================
 *  Raycasterï¼ˆé£ŸæŒ‡ hoverï¼‰
 * ====================================================== */
const raycaster = new THREE.Raycaster();
let hoveredPhoto = null;

/* ======================================================
 *  æ‰‹åŠ¿çŠ¶æ€
 * ====================================================== */
let pinchStrength = 0;      // 0~1
let detailMode = false;
let lastPinchStart = 0;

let targetRotationY = 0;
let lastHandSeenAt = 0;

let mode = "TREE";          // TREE / CLOUD
let targetCloudMix = 0;     // 0=æ ‘å½¢ï¼Œ1=æ˜Ÿäº‘
let cloudMix = 0;

/* ======================================================
 *  MediaPipe Handsï¼ˆä¸è‡ªåŠ¨å¯åŠ¨ï¼Œç­‰ç”¨æˆ·ç‚¹æŒ‰é’®ï¼‰
 * ====================================================== */
const video = document.getElementById("video");
const hands = new Hands({
  locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults((results) => {
  const lm = results.multiHandLandmarks?.[0];
  if (!lm) return;

  lastHandSeenAt = performance.now();

  const indexTip = lm[8];
  const thumbTip = lm[4];

  // pinch
  const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
  pinchStrength = THREE.MathUtils.clamp(
    (PARAMS.PINCH_MAX - d) / (PARAMS.PINCH_MAX - PARAMS.PINCH_MIN),
    0, 1
  );

  // æ—‹è½¬ï¼šç”¨é£ŸæŒ‡ x æ§åˆ¶
  const handX = indexTip.x - 0.5; // -0.5~0.5
  targetRotationY = THREE.MathUtils.clamp(handX * 2.0, -1.2, 1.2);

  // Raycasterï¼šç”¨é£ŸæŒ‡ä½œä¸ºå…‰æ ‡
  const ndc = { x: indexTip.x * 2 - 1, y: -(indexTip.y * 2 - 1) };
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(photoMeshes);
  hoveredPhoto = hits[0]?.object || null;

  // å¼€æŒ/æ¡æ‹³å¯å‘å¼ï¼šæŒ‡å°–åˆ°æŒå¿ƒè·ç¦»å’Œ
  const palm = lm[0];
  const tips = [lm[8], lm[12], lm[16], lm[20]];
  const sumDist = tips.reduce((acc, p) => acc + Math.hypot(p.x - palm.x, p.y - palm.y), 0);

  const OPEN_THRESHOLD = 0.55;
  const FIST_THRESHOLD = 0.38;

  if (sumDist > OPEN_THRESHOLD) mode = "CLOUD";
  else if (sumDist < FIST_THRESHOLD) mode = "TREE";

  targetCloudMix = (mode === "CLOUD") ? 1 : 0;

  // è¯¦æƒ…æ¨¡å¼ï¼šå¼º pinch ä¸” hover æœ‰å¯¹è±¡ï¼ŒæŒç»­ 300ms
  if (pinchStrength > 0.8 && hoveredPhoto) {
    if (!lastPinchStart) lastPinchStart = performance.now();
    if (performance.now() - lastPinchStart > PARAMS.DETAIL_HOLD_MS) detailMode = true;
  } else {
    lastPinchStart = 0;
    detailMode = false;
  }
});

/* ======================================================
 *  ç‚¹å‡»å¼€å§‹ä½“éªŒ -> è§¦å‘æ‘„åƒå¤´æƒé™ï¼ˆå…³é”®ï¼ï¼‰
 * ====================================================== */
let cameraMP = null;
let started = false;

async function startExperience() {
  if (started) return;
  started = true;

  const btn = document.getElementById("startBtn");
  btn.disabled = true;
  setStatus("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™â€¦ï¼ˆè¯·å…è®¸ï¼‰");

  try {
    // å…ˆæ¢æµ‹ä¸€æ¬¡æƒé™æ›´å‹å¥½ï¼ˆéƒ¨åˆ†æµè§ˆå™¨æ— æ­¤ API ä¹Ÿæ²¡å…³ç³»ï¼‰
    // ä¸å¼ºä¾èµ–ï¼Œå¤±è´¥å°±ç»§ç»­èµ° start
    // await navigator.mediaDevices.getUserMedia({ video: true });

    cameraMP = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480
    });

    await cameraMP.start();
    setStatus("æ‘„åƒå¤´å·²å¼€å¯ âœ…ï¼ˆå¯å¼€å§‹æ‰‹åŠ¿äº¤äº’ï¼‰");
  } catch (e) {
    console.error(e);
    started = false;
    btn.disabled = false;

    // å¸¸è§ï¼šç”¨æˆ·æ‹’ç»/ç³»ç»Ÿç¦ç”¨
    const msg = (e && (e.message || e.name)) ? (e.name + ": " + e.message) : String(e);
    setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ âŒ");
    showError(
      "âŒ æ‘„åƒå¤´æ— æ³•å¯åŠ¨ã€‚\n\n" +
      "å¯èƒ½åŸå› ï¼š\n" +
      "1) ä½ æ›¾ç»å¯¹è¯¥ç«™ç‚¹ç‚¹è¿‡â€œé˜»æ­¢æ‘„åƒå¤´â€ï¼ˆChrome ä¼šè®°ä½ï¼Œä¸å†å¼¹çª—ï¼‰\n" +
      "2) ç³»ç»Ÿæƒé™æœªå…è®¸ Chrome ä½¿ç”¨æ‘„åƒå¤´\n" +
      "3) ç”µè„‘æ²¡æœ‰æ‘„åƒå¤´/è¢«å…¶ä»–ç¨‹åºå ç”¨\n\n" +
      "é”™è¯¯ä¿¡æ¯ï¼š\n" + msg + "\n\n" +
      "è§£å†³ï¼šç‚¹å‡»åœ°å€æ å·¦ä¾§å°é” â†’ ç½‘ç«™è®¾ç½® â†’ æ‘„åƒå¤´ â†’ å…è®¸ï¼Œç„¶ååˆ·æ–°å†ç‚¹å¼€å§‹ä½“éªŒã€‚"
    );
  }
}
document.getElementById("startBtn").addEventListener("click", startExperience);

/* ======================================================
 *  åŠ¨ç”»å¾ªç¯
 * ====================================================== */
const tmpV3 = new THREE.Vector3();

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();

  // æ— æ‰‹å›é€€
  if (now - lastHandSeenAt > PARAMS.NO_HAND_TIMEOUT_MS) {
    pinchStrength = 0;
    detailMode = false;
    hoveredPhoto = null;
    mode = "TREE";
    targetCloudMix = 0;
    targetRotationY = 0;
  }

  // ç²’å­æ··åˆ
  cloudMix = THREE.MathUtils.lerp(cloudMix, targetCloudMix, 0.04);

  const pos = geom.attributes.position.array;
  for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
    const bi = i * 3;
    const bx = basePositions[bi];
    const by = basePositions[bi + 1];
    const bz = basePositions[bi + 2];

    const cx = cloudPositions[bi];
    const cy = cloudPositions[bi + 1];
    const cz = cloudPositions[bi + 2];

    const floatY = Math.sin((Date.now() * 0.001) + i) * 0.02;

    pos[bi]     = THREE.MathUtils.lerp(bx, cx, cloudMix);
    pos[bi + 1] = THREE.MathUtils.lerp(by + floatY, cy, cloudMix);
    pos[bi + 2] = THREE.MathUtils.lerp(bz, cz, cloudMix);
  }
  geom.attributes.position.needsUpdate = true;

  // æ—‹è½¬
  treePoints.rotation.y = THREE.MathUtils.lerp(treePoints.rotation.y, targetRotationY, 0.08);
  photoGroup.rotation.y = treePoints.rotation.y;

  // æ˜Ÿæ˜Ÿå‘¼å¸
  star.scale.setScalar(1 + Math.sin(Date.now() * 0.002) * 0.05);

  // ç…§ç‰‡ hover + pinch ç¼©æ”¾ + è¯¦æƒ…æ¨¡å¼æ·¡å‡º
  for (const m of photoMeshes) {
    const isHover = (hoveredPhoto === m);
    const targetScale = isHover ? (1 + pinchStrength * 1.6) : 1;
    m.scale.lerp(tmpV3.set(targetScale, targetScale, 1), 0.15);

    const baseOpacity = (detailMode && !isHover) ? 0.18 : 1;
    m.material.opacity = THREE.MathUtils.lerp(m.material.opacity, baseOpacity, 0.12);
  }

  // è¯¦æƒ…æ¨¡å¼ï¼šæŠŠé€‰ä¸­çš„ç…§ç‰‡æ‹‰åˆ°é•œå¤´å‰
  if (detailMode && hoveredPhoto) {
    hoveredPhoto.position.lerp(new THREE.Vector3(0, PARAMS.TREE_HEIGHT * 0.55, 2.2), 0.08);
  }

  // æœªå¯åŠ¨æ‘„åƒå¤´ä¹Ÿç»™ä¸€ç‚¹ç‚¹è‡ªè½¬ï¼Œé¿å…é™æ€é»‘å±é”™è§‰
  if (!started || (now - lastHandSeenAt > PARAMS.NO_HAND_TIMEOUT_MS)) {
    treePoints.rotation.y += PARAMS.DEFAULT_ROTATE_SPEED;
    photoGroup.rotation.y = treePoints.rotation.y;
  }

  renderer.render(scene, camera);
}

animate();

/* ======================================================
 *  resize
 * ====================================================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
