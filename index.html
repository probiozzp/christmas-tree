<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Luxury Interactive Christmas Tree (Vanilla + Three.js + MediaPipe)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#05080f; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial; }
    #app { position:fixed; inset:0; }
    canvas.webgl { position:absolute; inset:0; width:100%; height:100%; display:block; }
    /* 顶部 UI */
    .hud {
      position: absolute; left: 14px; top: 14px; z-index: 10;
      padding: 12px 14px; border-radius: 16px;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92); backdrop-filter: blur(10px);
      max-width: 560px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
    }
    .title { font-weight: 700; letter-spacing: 0.2px; }
    .sub { font-size: 12px; opacity: 0.85; margin-top: 6px; line-height: 1.35; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap:wrap; margin-top: 10px; }
    button {
      appearance:none; border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 14px;
      cursor:pointer; font-weight: 600; font-size: 13px;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .debug { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: 0.85; margin-top: 10px; line-height: 1.35; }

    /* 右上角摄像头面板 */
    .panel {
      position:absolute; right: 14px; top: 14px; z-index:10;
      width: 360px; border-radius: 16px; overflow:hidden;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.9);
    }
    .panelHead { display:flex; justify-content:space-between; align-items:center; padding: 10px 12px; font-size: 12px; border-bottom: 1px solid rgba(255,255,255,0.10); }
    .panelBody { position:relative; width: 100%; aspect-ratio: 16/9; background: #000; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); }
    canvas#overlay { position:absolute; inset:0; width:100%; height:100%; }
    .panelFoot { padding: 10px 12px; font-size: 11px; opacity: 0.78; border-top: 1px solid rgba(255,255,255,0.10); line-height: 1.35; white-space: pre-line; }
  </style>
</head>
<body>
  <div id="app">
    <canvas class="webgl" id="webgl"></canvas>

    <div class="hud">
      <div class="title">Grand Luxury Interactive Christmas Tree</div>
      <div class="sub">
        深祖母绿 + 高光金色 + 梦幻辉光。<br/>
        手势：张开→散开(CHAOS)，握拳→聚合(FORMED)；手左右滑动→稳定旋转视角（不甩飞）。<br/>
        拍立得：食指指尖 hover；捏合缩放；若没 hover，捏合会自动放大“离相机最近”的照片；捏合保持 300ms 进入详情模式。
      </div>

      <div class="row">
        <button id="btnStart">▶ 开始体验（开启摄像头）</button>
        <button id="btnReset">↺ 重置视角</button>
        <span id="status" style="font-size:12px; opacity:0.85;">未启动</span>
      </div>

      <div class="debug" id="debug">
        hand: false | mode: FORMED | radius: 20.0 | yaw: 0.00 | roll: 0.00
      </div>
    </div>

    <div class="panel">
      <div class="panelHead">
        <div>Hand Preview</div>
        <div id="camFlag" style="font-family: ui-monospace; opacity:0.8;">OFF</div>
      </div>
      <div class="panelBody">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="panelFoot">
如果没弹权限：地址栏小锁 → Camera → Allow → 刷新（加 ?v=数字）
注意：必须 https 或 localhost 才能稳定访问摄像头
      </div>
    </div>
  </div>

  <!-- ✅ MediaPipe Hands：常规 <script> 引入，得到全局 Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <!-- Three.js 用现代 module -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    /*************************************************************
     * 0) 小工具
     *************************************************************/
    const clamp01 = (v) => Math.max(0, Math.min(1, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
    const deadzone = (v, dz) => (Math.abs(v) < dz ? 0 : (v > 0 ? (v - dz) / (1 - dz) : (v + dz) / (1 - dz)));

    /*************************************************************
     * 1) DOM
     *************************************************************/
    const canvas = document.getElementById("webgl");
    const btnStart = document.getElementById("btnStart");
    const btnReset = document.getElementById("btnReset");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const camFlagEl = document.getElementById("camFlag");

    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const octx = overlay.getContext("2d");

    /*************************************************************
     * 2) Three.js：scene / camera / renderer
     *************************************************************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#05080f");
    scene.fog = new THREE.Fog("#05080f", 10, 55);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
    const treeCenter = new THREE.Vector3(0, 4, 0);

    // 相机状态（手势驱动）
    const cameraState = {
      radius: 20,
      targetRadius: 20,
      yaw: 0,
      targetYaw: 0,
      pitch: 0.08,
      targetPitch: 0.08,
    };

    // ✅ 优化左右控制：用“增量式 yaw”避免一甩飞（改动点 #2）
    const orbitInput = {
      yawVel: 0,          // 当前 yaw 速度
      targetYawVel: 0,    // 目标 yaw 速度（由手输入）
    };

    function applyCamera(dt) {
      cameraState.radius = damp(cameraState.radius, cameraState.targetRadius, 5.0, dt);
      cameraState.yaw    = damp(cameraState.yaw,    cameraState.targetYaw,    6.0, dt);
      cameraState.pitch  = damp(cameraState.pitch,  cameraState.targetPitch,  6.0, dt);

      const r = cameraState.radius;
      const yaw = cameraState.yaw;
      const pitch = cameraState.pitch;

      const x = Math.sin(yaw) * Math.cos(pitch) * r;
      const z = Math.cos(yaw) * Math.cos(pitch) * r;
      const y = Math.sin(pitch) * r;

      camera.position.set(x, y + treeCenter.y, z);
      camera.lookAt(treeCenter);
    }

    /*************************************************************
     * 3) 灯光
     *************************************************************/
    scene.add(new THREE.AmbientLight(0xffffff, 0.14));

    const key = new THREE.DirectionalLight("#ffd27d", 2.6);
    key.position.set(8, 14, 10);
    scene.add(key);

    const fill = new THREE.DirectionalLight("#9bdcff", 0.55);
    fill.position.set(-10, 8, -12);
    scene.add(fill);

    const emeraldGlow = new THREE.PointLight("#4cffc0", 0.25, 80);
    emeraldGlow.position.set(0, 6, 12);
    scene.add(emeraldGlow);

    /*************************************************************
     * 4) 圣诞树核心（不改树的构成/粒子/挂件逻辑）
     *************************************************************/
    const MODE = { FORMED: 0, CHAOS: 1 };
    let mode = MODE.FORMED;

    let mix = 0;
    let targetMix = 0;

    const TREE_H = 6.6;
    const TREE_R = 3.6;

    const root = new THREE.Group();
    scene.add(root);

    /*************************************************************
     * 4.1 树表面闪烁粒子（Points）
     *************************************************************/
    const SURFACE_COUNT = 8000;
    const surfaceGeo = new THREE.BufferGeometry();
    const surfacePos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceTarget = new Float32Array(SURFACE_COUNT * 3);
    const surfaceChaos = new Float32Array(SURFACE_COUNT * 3);
    const surfaceSeed = new Float32Array(SURFACE_COUNT);

    function conePoint() {
      const y = Math.random() * TREE_H;
      const radius = (1 - y / TREE_H) * TREE_R;
      const a = Math.random() * Math.PI * 2;
      const x = Math.cos(a) * radius + (Math.random() - 0.5) * 0.12;
      const z = Math.sin(a) * radius + (Math.random() - 0.5) * 0.12;
      return new THREE.Vector3(x, y, z);
    }
    function chaosPoint() {
      const rr = 16 + Math.random() * 20;
      return new THREE.Vector3(
        (Math.random() - 0.5) * rr,
        (Math.random() - 0.5) * rr * 0.7 + 3.2,
        (Math.random() - 0.5) * rr
      );
    }

    for (let i = 0; i < SURFACE_COUNT; i++) {
      const t = conePoint();
      const c = chaosPoint();
      surfaceTarget.set([t.x, t.y, t.z], i * 3);
      surfaceChaos.set([c.x, c.y, c.z], i * 3);
      surfacePos.set([t.x, t.y, t.z], i * 3);
      surfaceSeed[i] = Math.random();
    }
    surfaceGeo.setAttribute("position", new THREE.BufferAttribute(surfacePos, 3));
    surfaceGeo.setAttribute("aTarget", new THREE.BufferAttribute(surfaceTarget, 3));
    surfaceGeo.setAttribute("aChaos", new THREE.BufferAttribute(surfaceChaos, 3));
    surfaceGeo.setAttribute("aSeed", new THREE.BufferAttribute(surfaceSeed, 1));

    const surfaceMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },
        uEmerald: { value: new THREE.Color("#0a3a2c") },
        uGold: { value: new THREE.Color("#ffd27d") },
        uWhite: { value: new THREE.Color("#ffffff") },
      },
      vertexShader: `
        attribute vec3 aTarget;
        attribute vec3 aChaos;
        attribute float aSeed;

        uniform float uTime;
        uniform float uMix;

        varying float vGlow;
        varying float vTw;

        float hash(float n){ return fract(sin(n)*43758.5453123); }

        void main(){
          vec3 p = mix(aTarget, aChaos, uMix);

          float n = hash(aSeed*17.0);
          p.y += sin(uTime*1.25 + aSeed*6.2831) * 0.035 * (0.2 + 0.8*n);
          p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
          p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;

          vGlow = smoothstep(1.6, 6.6, p.y);

          float tw = sin(uTime*3.1 + aSeed*40.0) * 0.5 + 0.5;
          vTw = smoothstep(0.86, 1.0, tw) * (0.25 + 0.75*vGlow);

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = mix(7.0, 18.0, vGlow);
          size += vTw * 8.0;
          size *= (0.85 + n*0.4);
          gl_PointSize = size * (1.0 / -mv.z);
        }
      `,
      fragmentShader: `
        precision highp float;

        uniform vec3 uEmerald;
        uniform vec3 uGold;
        uniform vec3 uWhite;

        varying float vGlow;
        varying float vTw;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.28, 0.0, d);
          float halo = smoothstep(0.62, 0.15, d);

          vec3 base = mix(uEmerald, uGold, vGlow*0.95);
          vec3 spark = mix(uGold, uWhite, 0.6);
          vec3 col = base + spark * vTw * (0.35 + core*0.9);

          float a = halo;
          gl_FragColor = vec4(col, a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const surfacePoints = new THREE.Points(surfaceGeo, surfaceMat);
    root.add(surfacePoints);

    /*************************************************************
     * 4.2 挂件 InstancedMesh（保持不变）
     *************************************************************/
    const ORN_COUNT = 900;
    const ornGroup = new THREE.Group();
    root.add(ornGroup);

    const ballCount = Math.floor(ORN_COUNT * 0.55);
    const boxCount  = Math.floor(ORN_COUNT * 0.25);
    const lampCount = ORN_COUNT - ballCount - boxCount;

    function makeInstanced(geo, mat, count) {
      const im = new THREE.InstancedMesh(geo, mat, count);
      im.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      return im;
    }

    const ballGeo = new THREE.SphereGeometry(0.08, 12, 12);
    const boxGeo  = new THREE.BoxGeometry(0.13, 0.13, 0.13);
    const lampGeo = new THREE.SphereGeometry(0.045, 10, 10);

    const gold = new THREE.Color("#ffd27d");
    const emerald = new THREE.Color("#0a3a2c");

    const ballMat = new THREE.MeshStandardMaterial({ color: gold, metalness: 0.75, roughness: 0.18, emissive: gold, emissiveIntensity: 0.12 });
    const boxMat  = new THREE.MeshStandardMaterial({ color: emerald, metalness: 0.40, roughness: 0.28, emissive: gold, emissiveIntensity: 0.06 });
    const lampMat = new THREE.MeshStandardMaterial({ color: new THREE.Color("#ffffff"), metalness: 0.1, roughness: 0.15, emissive: new THREE.Color("#ffffff"), emissiveIntensity: 0.55 });

    const balls = makeInstanced(ballGeo, ballMat, ballCount);
    const boxes = makeInstanced(boxGeo, boxMat, boxCount);
    const lamps = makeInstanced(lampGeo, lampMat, lampCount);

    ornGroup.add(balls, boxes, lamps);

    const ornTarget = [];
    const ornChaos = [];
    const ornWeight = [];

    function randomConeOrn() {
      const y = Math.random() * (TREE_H * 0.85) + 0.6;
      const r = (1 - y / TREE_H) * TREE_R + 0.25;
      const a = Math.random() * Math.PI * 2;
      return new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
    }

    for (let i = 0; i < ORN_COUNT; i++) {
      ornTarget.push(randomConeOrn());
      ornChaos.push(chaosPoint());
      if (i < ballCount) ornWeight.push(1.0);
      else if (i < ballCount + boxCount) ornWeight.push(2.2);
      else ornWeight.push(0.6);
    }

    const tmpObj = new THREE.Object3D();

    function updateOrnaments(dt, time) {
      const tMix = mix;
      const breathe = (Math.sin(time * 1.2) * 0.5 + 0.5) * 0.06;

      for (let i = 0; i < ballCount; i++) {
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.6 + i * 0.03) * 0.02;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.7 + i) * 0.15,
          Math.cos(time * 0.6 + i) * 0.2,
          Math.sin(time * 0.5 + i) * 0.1
        );
        const s = 1.0 + breathe;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        balls.setMatrixAt(i, tmpObj.matrix);
      }
      balls.instanceMatrix.needsUpdate = true;

      for (let j = 0; j < boxCount; j++) {
        const i = ballCount + j;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 1.1 + i * 0.02) * 0.015;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(
          Math.sin(time * 0.3 + i) * 0.25,
          Math.cos(time * 0.35 + i) * 0.35,
          Math.sin(time * 0.28 + i) * 0.2
        );
        const s = 1.0 + breathe * 0.8;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        boxes.setMatrixAt(j, tmpObj.matrix);
      }
      boxes.instanceMatrix.needsUpdate = true;

      for (let k = 0; k < lampCount; k++) {
        const i = ballCount + boxCount + k;
        const tp = ornTarget[i];
        const cp = ornChaos[i];

        const x = lerp(tp.x, cp.x, tMix);
        const y = lerp(tp.y, cp.y, tMix) + Math.sin(time * 2.6 + i * 0.05) * 0.03;
        const z = lerp(tp.z, cp.z, tMix);

        tmpObj.position.set(x, y, z);
        tmpObj.rotation.set(0, 0, 0);
        const tw = (Math.sin(time * 4.5 + i * 0.9) * 0.5 + 0.5);
        const s = 1.0 + tw * 0.6;
        tmpObj.scale.setScalar(s);
        tmpObj.updateMatrix();
        lamps.setMatrixAt(k, tmpObj.matrix);
      }
      lamps.instanceMatrix.needsUpdate = true;
    }

    /*************************************************************
     * 4.3 顶部星星：✅改为“竖着的五角星”（改动点 #1）
     *************************************************************/
    const star = new THREE.Group();
    star.position.set(0, TREE_H + 0.55, 0);
    root.add(star);

    function makeRadialTexture() {
      const c = document.createElement("canvas");
      c.width = 256; c.height = 256;
      const ctx = c.getContext("2d");
      const g = ctx.createRadialGradient(128,128,0,128,128,128);
      g.addColorStop(0.0, "rgba(255,210,125,0.55)");
      g.addColorStop(0.25,"rgba(255,210,125,0.25)");
      g.addColorStop(0.6, "rgba(255,210,125,0.08)");
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,256,256);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const glowTex = makeRadialTexture();

    function makeFivePointStarShape(R = 0.42, r = 0.18) {
      // 五角星 2D shape（中心在 0,0）
      const shape = new THREE.Shape();
      const pts = [];
      const n = 5;
      const start = -Math.PI / 2; // 顶点朝上
      for (let i = 0; i < n * 2; i++) {
        const ang = start + (i * Math.PI) / n;
        const rad = (i % 2 === 0) ? R : r;
        pts.push(new THREE.Vector2(Math.cos(ang) * rad, Math.sin(ang) * rad));
      }
      shape.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) shape.lineTo(pts[i].x, pts[i].y);
      shape.closePath();
      return shape;
    }

    const starShape = makeFivePointStarShape(0.46, 0.20);
    const starGeo = new THREE.ExtrudeGeometry(starShape, {
      depth: 0.12,
      bevelEnabled: true,
      bevelThickness: 0.03,
      bevelSize: 0.02,
      bevelSegments: 2,
      curveSegments: 10,
    });
    starGeo.center();

    const starMat = new THREE.MeshStandardMaterial({
      color: "#ffd27d",
      metalness: 0.95,
      roughness: 0.12,
      emissive: "#ffd27d",
      emissiveIntensity: 0.9,
    });

    const starMesh = new THREE.Mesh(starGeo, starMat);
    // “竖着”：默认五角星面在 XY 平面，我们让它竖着朝向相机（像招牌一样）
    // 由于相机绕 y 旋转，我们每帧让星星 billboard（lookAt 相机），达到“始终竖着对着你”
    starMesh.rotation.y = 0;
    star.add(starMesh);

    const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
      map: glowTex,
      color: "#ffd27d",
      transparent: true,
      opacity: 0.65,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    }));
    glowSprite.scale.set(3.6, 3.6, 1);
    star.add(glowSprite);

    /*************************************************************
     * 5) 白色粒子光晕（保持不变）
     *************************************************************/
    const HALO_COUNT = 2200;
    const haloGeo = new THREE.BufferGeometry();
    const haloPos = new Float32Array(HALO_COUNT * 3);
    const haloSeed = new Float32Array(HALO_COUNT);

    for (let i = 0; i < HALO_COUNT; i++) {
      const a = Math.random() * Math.PI * 2;
      const rad = 5.2 + Math.random() * 2.0;
      const y = 3.8 + (Math.random() - 0.5) * 2.0;
      haloPos.set([Math.cos(a) * rad, y, Math.sin(a) * rad], i * 3);
      haloSeed[i] = Math.random();
    }
    haloGeo.setAttribute("position", new THREE.BufferAttribute(haloPos, 3));
    haloGeo.setAttribute("aSeed", new THREE.BufferAttribute(haloSeed, 1));

    const haloMat = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0 } },
      vertexShader: `
        attribute float aSeed;
        uniform float uTime;
        varying float vA;
        void main(){
          vec3 p = position;

          float t = uTime;
          float wob = sin(t*0.8 + aSeed*6.2831) * 0.15;
          float spin = (t*0.18 + aSeed*6.2831);

          float cs = cos(spin), sn = sin(spin);
          p.xz = mat2(cs, -sn, sn, cs) * p.xz;

          p.y += wob;

          vec4 mv = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mv;

          float size = 4.0 + (sin(t*2.2 + aSeed*30.0)*0.5+0.5)*4.0;
          gl_PointSize = size * (1.0 / -mv.z);

          vA = 0.25 + (sin(t*1.6 + aSeed*20.0)*0.5+0.5)*0.35;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float a = smoothstep(0.6, 0.05, d) * vA;
          gl_FragColor = vec4(vec3(1.0), a);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const halo = new THREE.Points(haloGeo, haloMat);
    root.add(halo);

    /*************************************************************
     * 6) 拍立得照片挂件（内置 assets）
     *************************************************************/
    const raycaster = new THREE.Raycaster();
    const polaroidGroup = new THREE.Group();
    root.add(polaroidGroup);

    const POLAROIDS = [
      "./assets/1.jpg",
      "./assets/2.jpg",
      "./assets/3.jpg",
      "./assets/4.jpg",
      "./assets/5.jpg",
      "./assets/6.jpg"
    ];

    const textureLoader = new THREE.TextureLoader();

    function makePolaroid(tex) {
      tex.colorSpace = THREE.SRGBColorSpace;

      const g = new THREE.Group();

      const cardW = 1.18, cardH = 1.48;
      const photoW = 1.02, photoH = 0.86;
      const bottomH = 0.30;

      const frameMat = new THREE.MeshStandardMaterial({
        color: "#ffffff", roughness: 0.42, metalness: 0.05, transparent: true, opacity: 1
      });
      const frame = new THREE.Mesh(new THREE.PlaneGeometry(cardW, cardH), frameMat);
      g.add(frame);

      const photoMat = new THREE.MeshStandardMaterial({
        map: tex, roughness: 0.25, metalness: 0.05, transparent: true, opacity: 1
      });
      const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), photoMat);
      photo.position.set(0, 0.18, 0.002);
      g.add(photo);

      const bottomMat = new THREE.MeshStandardMaterial({
        color: "#f5f5f5", roughness: 0.75, metalness: 0.0, transparent: true, opacity: 1
      });
      const bottom = new THREE.Mesh(new THREE.PlaneGeometry(photoW, bottomH), bottomMat);
      bottom.position.set(0, -0.46, 0.002);
      g.add(bottom);

      const hit = new THREE.Mesh(new THREE.PlaneGeometry(cardW * 1.08, cardH * 1.08), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
      hit.position.set(0, 0, 0.004);
      g.add(hit);

      const hook = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.11, 0.04), new THREE.MeshStandardMaterial({ color: "#ffd27d", metalness: 0.85, roughness: 0.18 }));
      hook.position.set(0, cardH * 0.52, 0.01);
      g.add(hook);

      const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.7, 10), new THREE.MeshBasicMaterial({ color: "#ffffff", transparent: true, opacity: 0.45 }));
      wire.position.set(0, cardH * 0.52 + 0.35, 0.0);
      g.add(wire);

      const gloss = new THREE.Sprite(new THREE.SpriteMaterial({
        map: glowTex, color: "#ffffff", transparent: true, opacity: 0.0,
        blending: THREE.AdditiveBlending, depthWrite: false
      }));
      gloss.scale.set(1.8, 2.2, 1);
      gloss.position.set(0.0, 0.05, 0.03);
      g.add(gloss);

      g.userData = { frameMat, photoMat, bottomMat, glossMat: gloss.material, hit };
      return g;
    }

    const polaroids = [];

    async function loadPolaroids() {
      for (let i = 0; i < POLAROIDS.length; i++) {
        const url = POLAROIDS[i];
        try {
          const tex = await new Promise((resolve, reject) => {
            textureLoader.load(url, resolve, undefined, reject);
          });
          const card = makePolaroid(tex);

          const y = Math.random() * (TREE_H * 0.8) + 0.9;
          const r = (1 - y / TREE_H) * TREE_R + 1.05;
          const a = Math.random() * Math.PI * 2;
          const target = new THREE.Vector3(Math.cos(a) * r, y, Math.sin(a) * r);
          const chaos = chaosPoint();

          card.position.copy(target);
          card.lookAt(0, target.y, 0);
          card.rotateZ((Math.random() - 0.5) * 0.5);

          card.userData.index = i;
          card.userData.target = target;
          card.userData.chaos = chaos;
          card.userData.baseScale = 1.0;

          polaroidGroup.add(card);
          polaroids.push(card);
        } catch (e) {
          console.warn("加载图片失败：", url, e);
        }
      }
    }

    /*************************************************************
     * 7) 手势系统：MediaPipe Hands
     *************************************************************/
    let started = false;
    let mpHands = null;
    let stream = null;

    const handState = {
      hasHand: false,
      indexNDC: null,
      pinch: 0,
      open: false,
      fist: false,
      yaw: 0,
      roll: 0,
      size: 0,
      lastSeen: 0,
      hoverIndex: -1,
      selectedIndex: -1,
      detailMode: false,
      pinchHoldStart: 0
    };

    function drawLandmarks(lm) {
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;

      const dpr = Math.min(devicePixelRatio || 1, 2);
      if (overlay.width !== Math.floor(w * dpr) || overlay.height !== Math.floor(h * dpr)) {
        overlay.width = Math.floor(w * dpr);
        overlay.height = Math.floor(h * dpr);
        octx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      octx.clearRect(0, 0, w, h);

      if (!lm) return;

      octx.fillStyle = "rgba(255,210,125,0.95)";
      for (const p of lm) {
        octx.beginPath();
        octx.arc(p.x * w, p.y * h, 4, 0, Math.PI * 2);
        octx.fill();
      }
    }

    function hysteresis(value, onTh, offTh, current) {
      if (!current && value > onTh) return true;
      if (current && value < offTh) return false;
      return current;
    }

    function computeGestures(lm) {
      const wrist = lm[0];
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const midMcp = lm[9];
      const indexMcp = lm[5];
      const pinkyMcp = lm[17];

      let minX=1, minY=1, maxX=0, maxY=0;
      for (const p of lm) {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
      }
      const size = Math.hypot(maxX - minX, maxY - minY);

      const dPin = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
      let pinch = (PINCH_MAX - dPin) / (PINCH_MAX - PINCH_MIN);
      pinch = clamp01(pinch);

      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const openScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - wrist.x, p.y - wrist.y), 0);
      const fistScoreRaw = tips.reduce((acc, p) => acc + Math.hypot(p.x - midMcp.x, p.y - midMcp.y), 0);

      handState.open = hysteresis(openScoreRaw, 0.62, 0.50, handState.open);
      handState.fist = hysteresis(1.0 - fistScoreRaw, 0.32, 0.22, handState.fist);

      // yaw 输入（-1..1）：镜像修正，让左右直觉一致
      const centerX = (minX + maxX) * 0.5;
      let yaw = -((centerX - 0.5) * 2);

      const vx = pinkyMcp.x - indexMcp.x;
      const vy = pinkyMcp.y - indexMcp.y;
      const angle = Math.atan2(vy, vx);
      let roll = THREE.MathUtils.clamp(angle / 1.2, -1, 1);

      const ndcX = - (indexTip.x * 2 - 1);
      const ndcY = - (indexTip.y * 2 - 1);

      return { pinch, yaw, roll, size, ndcX, ndcY };
    }

    async function startMediaPipe() {
      if (started) return;
      started = true;
      btnStart.disabled = true;

      statusEl.textContent = "请求摄像头权限…";
      camFlagEl.textContent = "ON";

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();

      mpHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      mpHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: true
      });

      let inFlight = false;

      mpHands.onResults((results) => {
        const lm = results?.multiHandLandmarks?.[0];

        if (!lm) {
          drawLandmarks(null);
          handState.hasHand = false;
          return;
        }

        handState.hasHand = true;
        handState.lastSeen = performance.now();

        drawLandmarks(lm);

        const g = computeGestures(lm);

        const a = 0.18;
        handState.pinch = lerp(handState.pinch, g.pinch, a);
        handState.yaw   = lerp(handState.yaw,   g.yaw,   a);
        handState.roll  = lerp(handState.roll,  g.roll,  a);
        handState.size  = lerp(handState.size,  g.size,  a);

        handState.indexNDC = { x: g.ndcX, y: g.ndcY };

        // 状态机：张开->CHAOS；握拳->FORMED
        if (handState.fist) mode = MODE.FORMED;
        else if (handState.open) mode = MODE.CHAOS;

        // ✅ 左右滑动控制优化：把“绝对角度”改成“速度积分”（改动点 #2）
        // 让手居中时相机不动；越偏左右旋转越快；带死区避免抖动。
        const dx = deadzone(handState.yaw, 0.14);      // [-1..1] after deadzone
        const rollAssist = deadzone(handState.roll, 0.25) * 0.35; // 少量辅助
        orbitInput.targetYawVel = THREE.MathUtils.clamp((dx * 1.7 + rollAssist) * 1.25, -2.2, 2.2);
      });

      const pump = async () => {
        if (!mpHands) return;
        if (video.readyState >= 2 && !inFlight) {
          inFlight = true;
          try { await mpHands.send({ image: video }); } catch(e) {}
          inFlight = false;
        }
        requestAnimationFrame(pump);
      };
      requestAnimationFrame(pump);

      statusEl.textContent = "摄像头已开启 ✅";
    }

    btnStart.addEventListener("click", async () => {
      try {
        await startMediaPipe();
      } catch (e) {
        console.error(e);
        alert("摄像头启动失败。请检查：地址栏小锁→Camera Allow；必须 https 或 localhost；或系统隐私设置。");
        statusEl.textContent = "摄像头启动失败 ❌";
      }
    });

    btnReset.addEventListener("click", () => {
      orbitInput.yawVel = 0;
      orbitInput.targetYawVel = 0;
      cameraState.targetYaw = 0;
      cameraState.targetPitch = 0.08;
      cameraState.targetRadius = 20;
    });

    /*************************************************************
     * 8) Raycaster hover（保留），但 pinch 时会自动锁最近照片
     *************************************************************/
    function updateRaycastHover() {
      if (!handState.hasHand || !handState.indexNDC || polaroids.length === 0) {
        handState.hoverIndex = -1;
        return;
      }

      raycaster.setFromCamera(handState.indexNDC, camera);
      const hits = raycaster.intersectObjects(polaroidGroup.children, true);

      if (!hits.length) {
        handState.hoverIndex = -1;
        return;
      }

      let obj = hits[0].object;
      while (obj && obj.parent && obj.parent !== polaroidGroup) obj = obj.parent;
      const idx = obj?.userData?.index;
      handState.hoverIndex = (typeof idx === "number") ? idx : -1;
    }

    // ✅ 新增：pinch 时若没 hover，则选“离相机最近”的拍立得（改动点 #3）
    function findNearestPolaroidToCamera() {
      if (!polaroids.length) return -1;
      let best = -1;
      let bestD = Infinity;
      const camPos = camera.position;
      for (const card of polaroids) {
        const wp = new THREE.Vector3();
        card.getWorldPosition(wp);
        const d = wp.distanceTo(camPos);
        if (d < bestD) { bestD = d; best = card.userData.index; }
      }
      return best;
    }

    /*************************************************************
     * 9) update
     *************************************************************/
    function updateSurfacePositions(time) {
      surfaceMat.uniforms.uTime.value = time;
      surfaceMat.uniforms.uMix.value = mix;
    }

    function updatePolaroids(dt, time) {
      const tMix = mix;

      // pinch 自动锁最近：仅在 pinch 有效且 hover 为空时触发
      const pinchActive = handState.hasHand && handState.pinch > 0.22;
      if (pinchActive && handState.hoverIndex < 0) {
        handState.hoverIndex = findNearestPolaroidToCamera();
      }

      // 详情模式：hover（或最近锁定）+ pinch 持续 300ms
      const PINCH_DETAIL_ON = 0.72;
      const hovering = (handState.hoverIndex >= 0);

      if (hovering && handState.pinch > PINCH_DETAIL_ON) {
        if (!handState.pinchHoldStart) handState.pinchHoldStart = performance.now();
        if (performance.now() - handState.pinchHoldStart > 300) {
          handState.detailMode = true;
          handState.selectedIndex = handState.hoverIndex;
        }
      } else {
        handState.pinchHoldStart = 0;
        handState.detailMode = false;
        // 不强制清 selectedIndex，让它下次还能接着用；但无手会清
      }

      for (const card of polaroids) {
        const idx = card.userData.index;
        const target = card.userData.target;
        const chaos = card.userData.chaos;

        const isHover = (idx === handState.hoverIndex);
        const isSelected = (idx === handState.selectedIndex) && handState.detailMode;

        const p = new THREE.Vector3(
          lerp(target.x, chaos.x, tMix),
          lerp(target.y, chaos.y, tMix),
          lerp(target.z, chaos.z, tMix)
        );

        if (!isSelected) {
          card.position.lerp(p, 0.22);
          card.lookAt(0, card.position.y, 0);
          card.rotateZ(Math.sin(time * 0.9 + idx) * 0.06);
        }

        if (isSelected) {
          card.position.lerp(new THREE.Vector3(0, 4.2, 6.0), 0.12);
          card.rotation.x = damp(card.rotation.x, 0, 10, dt);
          card.rotation.y = damp(card.rotation.y, 0, 10, dt);
          card.rotation.z = damp(card.rotation.z, 0, 10, dt);
        }

        const pinch = handState.pinch;
        const base = isSelected ? 2.1 : 1.0;

        // ✅ pinch 放大：对 hover（或最近锁定）始终生效
        const zoom = isHover ? (1.0 + pinch * 2.2) : 1.0;
        const targetScale = base * zoom;
        card.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.18);

        const fadeOthers = handState.detailMode && !isSelected;
        const opacityTarget = fadeOthers ? 0.18 : 1.0;

        const { frameMat, photoMat, bottomMat, glossMat } = card.userData;
        frameMat.opacity  = damp(frameMat.opacity,  opacityTarget, 10, dt);
        photoMat.opacity  = damp(photoMat.opacity,  opacityTarget, 10, dt);
        bottomMat.opacity = damp(bottomMat.opacity, opacityTarget, 10, dt);

        const gl = (Math.sin(time * 1.7 + idx) * 0.5 + 0.5);
        const glossTarget = (isHover ? 0.25 : 0.06) * gl;
        glossMat.opacity = damp(glossMat.opacity, glossTarget, 10, dt);
      }
    }

    /*************************************************************
     * 10) 无手自动回归
     *************************************************************/
    function noHandFallback(now) {
      if (!handState.hasHand) {
        if (now - handState.lastSeen > 1000) {
          mode = MODE.FORMED;
          orbitInput.targetYawVel = 0;
          orbitInput.yawVel = damp(orbitInput.yawVel, 0, 6.0, 1/60);

          cameraState.targetYaw = damp(cameraState.targetYaw, 0, 3.0, 1/60);
          cameraState.targetRadius = damp(cameraState.targetRadius, 20, 3.0, 1/60);

          handState.pinch = damp(handState.pinch, 0, 6.0, 1/60);
          handState.hoverIndex = -1;
          handState.selectedIndex = -1;
          handState.detailMode = false;
        }
      }
    }

    /*************************************************************
     * 11) 主循环
     *************************************************************/
    let lastT = performance.now() * 0.001;

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now() * 0.001;
      const dt = Math.min(0.033, now - lastT);
      lastT = now;

      targetMix = (mode === MODE.CHAOS) ? 1 : 0;
      mix = damp(mix, targetMix, 2.6, dt);

      root.rotation.y += 0.0022;
      root.position.y = Math.sin(now * 0.7) * 0.03;

      // 星星：保持竖着且面对相机（招牌式）
      starMesh.lookAt(camera.position);
      star.rotation.y = now * 0.35; // 整体轻微旋转也可以保留一点“奢华动感”
      glowSprite.material.opacity = 0.55 + (Math.sin(now * 2.0) * 0.5 + 0.5) * 0.22;

      haloMat.uniforms.uTime.value = now;

      updateRaycastHover();
      updatePolaroids(dt, now);
      updateOrnaments(dt, now);
      updateSurfacePositions(now);

      noHandFallback(performance.now());

      // ✅ 优化相机 yaw：速度积分 + 限速 + 平滑
      orbitInput.yawVel = damp(orbitInput.yawVel, orbitInput.targetYawVel, 10.0, dt);
      cameraState.targetYaw += orbitInput.yawVel * dt;

      // 防止无限累积导致不舒服：把 yaw 限制在 [-pi, pi] 内（循环归一）
      if (cameraState.targetYaw > Math.PI) cameraState.targetYaw -= Math.PI * 2;
      if (cameraState.targetYaw < -Math.PI) cameraState.targetYaw += Math.PI * 2;

      // 注意：你之前的远近逻辑如果现在不想动，就保持默认 20（这里不再自动改 radius）
      // 你要求“不擅自改变树的外观和组成”，我这里把 radius 固定为默认体验（更稳）
      cameraState.targetRadius = 20;

      applyCamera(dt);

      debugEl.textContent =
        `hand: ${handState.hasHand} | mode: ${mode === MODE.CHAOS ? "CHAOS" : "FORMED"} | radius: ${cameraState.radius.toFixed(1)} | yaw: ${cameraState.yaw.toFixed(2)}\n` +
        `open: ${handState.open} | fist: ${handState.fist} | pinch: ${handState.pinch.toFixed(2)} | yawVel: ${orbitInput.yawVel.toFixed(2)}\n` +
        `hover: ${handState.hoverIndex} | detail: ${handState.detailMode} | selected: ${handState.selectedIndex}`;

      renderer.render(scene, camera);
    }

    /*************************************************************
     * 12) resize
     *************************************************************/
    window.addEventListener("resize", () => {
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
    });

    /*************************************************************
     * 13) init
     *************************************************************/
    cameraState.radius = 20;
    cameraState.targetRadius = 20;
    cameraState.yaw = 0;
    cameraState.targetYaw = 0;
    applyCamera(0.016);

    loadPolaroids();
    animate();

    statusEl.textContent = "已加载场景（点击开始体验开启摄像头）";
  </script>
</body>
</html>
