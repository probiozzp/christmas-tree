<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Grand Luxury Interactive Christmas Tree (R3F Single HTML)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #root { margin:0; width:100%; height:100%; background:#05080f; overflow:hidden; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
<div id="root"></div>

<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

<script type="module">
import React, { useRef, useState, useMemo, useEffect } from "https://esm.sh/react@19";
import ReactDOM from "https://esm.sh/react-dom@19/client";
import { Canvas, useFrame, useThree } from "https://esm.sh/@react-three/fiber";
import { Environment } from "https://esm.sh/@react-three/drei";
import { EffectComposer, Bloom } from "https://esm.sh/@react-three/postprocessing";
import * as THREE from "https://esm.sh/three";

/* ---------- utils ---------- */
const clamp01 = (v) => Math.max(0, Math.min(1, v));
const lerp = (a,b,t) => a + (b-a)*t;
const damp = (current, target, lambda, dt) => lerp(current, target, 1 - Math.exp(-lambda * dt));
const hysteresis = (value, onTh, offTh, currentBool) => {
  if (!currentBool && value > onTh) return true;
  if (currentBool && value < offTh) return false;
  return currentBool;
};

const MODE = { FORMED: 0, CHAOS: 1 };
const COLORS = {
  bg: "#05080f",
  emerald: new THREE.Color("#0a3a2c"),
  gold: new THREE.Color("#ffd27d"),
  white: new THREE.Color("#ffffff"),
};

/* ---------- GitHub assets listing ---------- */
function inferGithubRepo() {
  const host = location.hostname;
  const owner = host.endsWith(".github.io") ? host.replace(".github.io","") : "probiozzp";
  const seg = location.pathname.split("/").filter(Boolean);
  const repo = seg.length ? seg[0] : "christmas-tree";
  return { owner, repo };
}
async function listAssetsImages() {
  const { owner, repo } = inferGithubRepo();
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/assets`;
  const exts = [".png",".jpg",".jpeg",".webp",".gif"];
  const res = await fetch(api, { cache: "no-store" });
  if (!res.ok) return [];
  const items = await res.json();
  return items
    .filter(it => it.type === "file" && exts.some(ext => it.name.toLowerCase().endsWith(ext)))
    .map(it => it.name);
}

/* =========================================================
   Foliage: Points + Shader
========================================================= */
function Foliage({ mixRef }) {
  const COUNT = 8500;
  const H = 6.5, R = 3.4;

  const geom = useMemo(() => {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const target = new Float32Array(COUNT*3);
    const chaos = new Float32Array(COUNT*3);
    const seed = new Float32Array(COUNT);
    const spark = new Float32Array(COUNT);

    for (let i=0;i<COUNT;i++){
      const y = Math.random() * H;
      const radius = (1 - y/H) * R;
      const a = Math.random() * Math.PI*2;
      target.set([Math.cos(a)*radius, y, Math.sin(a)*radius], i*3);

      // CHAOS 更“夸张”：更大球空间
      const rr = 12 + Math.random()*18;
      chaos.set([(Math.random()-0.5)*rr, (Math.random()-0.5)*rr*0.7 + 2.0, (Math.random()-0.5)*rr], i*3);

      pos.set([0,0,0], i*3);
      seed[i] = Math.random();
      spark[i] = Math.random();
    }
    g.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    g.setAttribute("aTarget", new THREE.BufferAttribute(target, 3));
    g.setAttribute("aChaos", new THREE.BufferAttribute(chaos, 3));
    g.setAttribute("aSeed", new THREE.BufferAttribute(seed, 1));
    g.setAttribute("aSpark", new THREE.BufferAttribute(spark, 1));
    return g;
  }, []);

  const mat = useMemo(() => new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uMix: { value: 0 },
      uEmerald: { value: COLORS.emerald },
      uGold: { value: COLORS.gold },
      uWhite: { value: COLORS.white },
    },
    vertexShader: `
      attribute vec3 aTarget;
      attribute vec3 aChaos;
      attribute float aSeed;
      attribute float aSpark;

      uniform float uTime;
      uniform float uMix;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      float hash(float n){ return fract(sin(n)*43758.5453123); }

      void main(){
        vec3 p = mix(aTarget, aChaos, uMix);

        float n = hash(aSeed*17.0);
        p.y += sin(uTime*1.2 + aSeed*6.2831) * 0.03 * (0.25 + 0.75*n);
        p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
        p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;

        vGlow = smoothstep(1.8, 6.8, p.y);

        float tw = sin(uTime*3.2 + aSpark*40.0) * 0.5 + 0.5;
        vSpark = smoothstep(0.86, 1.0, tw) * (0.25 + 0.75*vGlow);

        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mv;

        float size = mix(7.0, 17.0, vGlow);
        size += vSpark * 7.0;
        size *= (0.85 + n*0.4);
        gl_PointSize = size * (1.0 / -mv.z);

        vAlpha = clamp(1.0 - (-mv.z / 45.0), 0.20, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      uniform vec3 uEmerald;
      uniform vec3 uGold;
      uniform vec3 uWhite;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);

        float core = smoothstep(0.28, 0.0, d);
        float halo = smoothstep(0.62, 0.15, d);

        vec3 base = mix(uEmerald, uGold, vGlow*0.95);
        vec3 sparkCol = mix(uGold, uWhite, 0.65);
        vec3 col = base + sparkCol * vSpark * (0.35 + core*0.8);

        float a = halo * vAlpha;
        gl_FragColor = vec4(col, a);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  }), []);

  useFrame((_, dt) => {
    mat.uniforms.uTime.value += dt;
    mat.uniforms.uMix.value = mixRef.current;
  });

  return <points geometry={geom} material={mat} />;
}

/* =========================================================
   Volumetric Gold: fake god rays
========================================================= */
function makeRadialTexture() {
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  const g = ctx.createRadialGradient(128,128,0,128,128,128);
  g.addColorStop(0.0, "rgba(255,210,125,0.40)");
  g.addColorStop(0.25,"rgba(255,210,125,0.22)");
  g.addColorStop(0.55,"rgba(255,210,125,0.08)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,256);
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}
function VolumetricGold() {
  const tex = useMemo(makeRadialTexture, []);
  const group = useRef();

  useFrame((_, dt) => {
    const t = performance.now()*0.001;
    if (!group.current) return;
    group.current.rotation.y = Math.sin(t*0.12) * 0.18;
    group.current.children.forEach((s, i) => {
      s.material.opacity = 0.20 + (Math.sin(t*1.1 + i*0.7)*0.5+0.5)*0.14;
    });
  });

  return (
    <group ref={group} position={[0, 3.8, -2]}>
      {new Array(8).fill(0).map((_,i)=>(
        <sprite key={i}
          scale={[20 - i*1.7, 11 - i*1.0, 1]}
          position={[0, 2.8 - i*0.18, -i*0.7]}
        >
          <spriteMaterial
            map={tex}
            transparent
            depthWrite={false}
            blending={THREE.AdditiveBlending}
            color={"#ffd27d"}
            opacity={0.25}
          />
        </sprite>
      ))}
    </group>
  );
}

/* =========================================================
   Polaroids
========================================================= */
function makeRoundedAlphaTexture(radiusPx=28){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  function rr(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  ctx.clearRect(0,0,256,256);
  ctx.fillStyle="rgba(255,255,255,1)";
  rr(18,18,220,220,radiusPx);
  ctx.fill();
  return new THREE.CanvasTexture(c);
}
function makePaperNoiseTex(){
  const c = document.createElement("canvas");
  c.width = 128; c.height = 128;
  const ctx = c.getContext("2d");
  const img = ctx.createImageData(128,128);
  for(let i=0;i<img.data.length;i+=4){
    const n = 200 + Math.floor(Math.random()*55);
    img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=255;
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(4,4);
  return tex;
}

function Polaroids({ mixRef, indexNDCRef, pinchRef, detailRef, hoverIndexRef, setHoverUI }) {
  const group = useRef();
  const { camera } = useThree();
  const raycaster = useMemo(() => new THREE.Raycaster(), []);

  const [cards, setCards] = useState([]);
  const loader = useMemo(() => new THREE.TextureLoader(), []);
  const roundAlpha = useMemo(() => makeRoundedAlphaTexture(28), []);
  const paperNoise = useMemo(() => makePaperNoiseTex(), []);

  useEffect(() => {
    let alive = true;
    (async ()=>{
      const names = await listAssetsImages().catch(()=>[]);
      if (!alive) return;

      const H = 6.5, R = 3.4;
      const makeTarget = () => {
        const y = Math.random() * (H*0.82) + 0.8;
        const r = (1 - y/H) * R + 1.0;
        const a = Math.random() * Math.PI*2;
        return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
      };
      const makeChaos = () => new THREE.Vector3((Math.random()-0.5)*18, (Math.random()-0.5)*12 + 2.5, (Math.random()-0.5)*18);

      const tasks = names.map(name => new Promise((resolve)=>{
        loader.load(`./assets/${encodeURIComponent(name)}`, (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          resolve({ name, tex, target: makeTarget(), chaos: makeChaos(), seed: Math.random() });
        }, undefined, ()=>resolve(null));
      }));

      const result = (await Promise.all(tasks)).filter(Boolean);
      if (!alive) return;
      setCards(result);
    })();
    return ()=>{ alive=false; };
  }, []);

  useFrame((_, dt) => {
    if (!group.current || !cards.length) return;

    // hover
    const ndc = indexNDCRef.current;
    let hoverIdx = -1;
    if (ndc) {
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(group.current.children, true);
      if (hits.length) {
        let p = hits[0].object;
        while (p && p.parent && p.parent !== group.current) p = p.parent;
        hoverIdx = p?.userData?.index ?? -1;
      }
    }
    if (hoverIndexRef.current !== hoverIdx) {
      hoverIndexRef.current = hoverIdx;
      setHoverUI(hoverIdx); // 只更新 UI，不再影响 hands effect
    }

    // update transforms
    const mix = mixRef.current;
    const pinch = pinchRef.current;
    const detail = detailRef.current;

    group.current.children.forEach((root) => {
      const i = root.userData.index;
      const d = cards[i];
      if (!d) return;

      const p = new THREE.Vector3().lerpVectors(d.target, d.chaos, mix);
      const t = performance.now()*0.001;
      const sway = Math.sin(t*0.9 + d.seed*10) * 0.10;
      const tilt = Math.cos(t*0.7 + d.seed*10) * 0.07;

      const isHover = (i === hoverIndexRef.current);

      if (detail && isHover) {
        root.position.lerp(new THREE.Vector3(0, 3.9, 6.1), 0.10);
        root.rotation.x = damp(root.rotation.x, 0, 10, dt);
        root.rotation.y = damp(root.rotation.y, 0, 10, dt);
        root.rotation.z = damp(root.rotation.z, 0, 10, dt);
      } else {
        root.position.lerp(p, 0.22);
        root.lookAt(0, root.position.y, 0);
        root.rotateZ(sway * 0.6);
        root.rotation.x += tilt*0.05;
        root.rotation.y += sway*0.03;
      }

      // pinch：更明显（放大更大，阈值更低也能看到）
      const targetS = isHover ? (1 + pinch*2.2) : 1.0;
      root.scale.lerp(new THREE.Vector3(targetS, targetS, targetS), 0.18);

      const opacity = (detail && !isHover) ? 0.18 : 1.0;
      const { frameMat, photoMat, bottomMat, glossMat } = root.userData;
      if (frameMat) frameMat.opacity = damp(frameMat.opacity, opacity, 10, dt);
      if (photoMat) photoMat.opacity = damp(photoMat.opacity, opacity, 10, dt);
      if (bottomMat) bottomMat.opacity = damp(bottomMat.opacity, opacity, 10, dt);

      if (glossMat) {
        const gl = (Math.sin(t*1.7 + d.seed*10)*0.5+0.5);
        const go = (isHover ? 0.26 : 0.08) * gl;
        glossMat.opacity = damp(glossMat.opacity, go, 10, dt);
      }
    });
  });

  if (!cards.length) return null;

  return (
    <group ref={group}>
      {cards.map((d, i) => {
        const frameMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color("#ffffff"),
          roughness: 0.42,
          metalness: 0.05,
          roughnessMap: paperNoise,
          alphaMap: roundAlpha,
          transparent: true,
          opacity: 1
        });
        const photoMat = new THREE.MeshStandardMaterial({
          map: d.tex,
          roughness: 0.25,
          metalness: 0.05,
          transparent: true,
          opacity: 1
        });
        const bottomMat = new THREE.MeshStandardMaterial({
          color: "#f5f5f5",
          roughness: 0.75,
          metalness: 0.0,
          roughnessMap: paperNoise,
          transparent: true,
          opacity: 1
        });
        const glossMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const cardW=1.12, cardH=1.38, photoW=0.96, photoH=0.80, bottomH=0.30;

        return (
          <group
            key={d.name}
            userData={{ index: i, frameMat, photoMat, bottomMat, glossMat }}
            position={[d.target.x, d.target.y, d.target.z]}
          >
            <mesh material={frameMat}>
              <planeGeometry args={[cardW, cardH]} />
            </mesh>
            <mesh material={photoMat} position={[0, 0.17, 0.002]}>
              <planeGeometry args={[photoW, photoH]} />
            </mesh>
            <mesh material={bottomMat} position={[0, -0.44, 0.002]}>
              <planeGeometry args={[photoW, bottomH]} />
            </mesh>
            <mesh material={glossMat} position={[0, 0, 0.003]}>
              <planeGeometry args={[cardW, cardH]} />
            </mesh>
            <mesh position={[0, cardH*0.52, 0.01]}>
              <boxGeometry args={[0.14, 0.11, 0.04]} />
              <meshStandardMaterial color={"#ffd27d"} metalness={0.75} roughness={0.2} />
            </mesh>
            <mesh position={[0, cardH*0.52 + 0.35, 0.0]}>
              <cylinderGeometry args={[0.008, 0.008, 0.7, 10]} />
              <meshBasicMaterial color={"#ffffff"} transparent opacity={0.45}/>
            </mesh>
            <mesh position={[0,0,0.004]}>
              <planeGeometry args={[1.25, 1.5]} />
              <meshBasicMaterial transparent opacity={0}/>
            </mesh>
          </group>
        );
      })}
    </group>
  );
}

/* =========================================================
   Scene: 用 group 旋转实现“手左右滑动”——不会被 lookAt 覆盖
========================================================= */
function Scene({ modeRef, handYawRef, indexNDCRef, pinchRef, detailRef, hoverIndexRef, setHoverUI }) {
  const mixRef = useRef(0);
  const treeGroup = useRef();
  const { camera } = useThree();

  useFrame((_, dt) => {
    // mix（CHAOS<->FORMED）
    const targetMix = (modeRef.current === MODE.CHAOS) ? 1 : 0;
    mixRef.current = damp(mixRef.current, targetMix, 2.6, dt);

    // tree 旋转（手左右控制）
    if (treeGroup.current) {
      treeGroup.current.rotation.y = damp(treeGroup.current.rotation.y, handYawRef.current, 6.0, dt);
      treeGroup.current.rotation.y += 0.002; // 慢慢自转更“展示”
    }

    // 相机仅做轻呼吸 + 固定看向中心（不再用 rotation.y）
    const t = performance.now()*0.001;
    const baseY = 4 + Math.sin(t*0.6)*0.15;
    camera.position.x = damp(camera.position.x, 0, 2.0, dt);
    camera.position.y = damp(camera.position.y, baseY, 2.0, dt);
    camera.position.z = damp(camera.position.z, 20, 2.0, dt);
    camera.lookAt(0, 4, 0);
  });

  return (
    <>
      <VolumetricGold />
      <group ref={treeGroup}>
        <Foliage mixRef={mixRef}/>
        <Polaroids
          mixRef={mixRef}
          indexNDCRef={indexNDCRef}
          pinchRef={pinchRef}
          detailRef={detailRef}
          hoverIndexRef={hoverIndexRef}
          setHoverUI={setHoverUI}
        />
      </group>
      <Environment preset="lobby" />
      <EffectComposer>
        <Bloom intensity={1.25} threshold={0.80} mipmapBlur />
      </EffectComposer>
    </>
  );
}

/* =========================================================
   App: Hands（关键修复：effect 不再依赖 hoverIndex）
========================================================= */
function App() {
  const [started, setStarted] = useState(false);
  const [status, setStatus] = useState("未启动（点击开始体验开启摄像头）");

  const [hoverUI, setHoverUI] = useState(-1);

  const videoRef = useRef(null);
  const canvasRef = useRef(null);

  const modeRef = useRef(MODE.FORMED);
  const openRef = useRef(false);
  const handYawRef = useRef(0);

  const indexNDCRef = useRef(null);
  const pinchRef = useRef(0);
  const detailRef = useRef(false);

  const hoverIndexRef = useRef(-1);

  const smoothHandX = useRef(0);
  const smoothPinch = useRef(0);
  const pinchHoldStart = useRef(0);

  // debug
  const openScoreRef = useRef(0);
  const handXRef = useRef(0);

  useEffect(() => {
    if (!started) return;

    let stream = null;
    let hands = null;
    let rafId = null;
    let inFlight = false;

    const video = videoRef.current;
    const overlay = canvasRef.current;
    const ctx = overlay?.getContext("2d");

    const resizeOverlay = () => {
      if (!overlay || !video) return;
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;
      const dpr = devicePixelRatio || 1;
      if (overlay.width !== Math.floor(w*dpr) || overlay.height !== Math.floor(h*dpr)) {
        overlay.width = Math.floor(w*dpr);
        overlay.height = Math.floor(h*dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    };

    const drawLandmarks = (lm) => {
      if (!ctx || !overlay) return;
      resizeOverlay();
      const w = overlay.clientWidth;
      const h = overlay.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!lm) return;
      ctx.fillStyle = "rgba(255,210,125,0.95)";
      for (const p of lm){
        ctx.beginPath();
        ctx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2);
        ctx.fill();
      }
    };

    const compute = (lm) => {
      const thumbTip = lm[4];
      const indexTip = lm[8];
      const palm = lm[0];

      const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
      const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
      let pinch = (PINCH_MAX - d) / (PINCH_MAX - PINCH_MIN);
      pinch = clamp01(pinch);

      // ✅ 轴修正：镜像方向统一（让左右更直觉）
      // 如果你觉得方向反了，只要把这里的负号删掉即可
      const handX = -((indexTip.x - 0.5) * 2);

      const tips = [lm[8], lm[12], lm[16], lm[20]];
      const openScore = tips.reduce((acc, p) => acc + Math.hypot(p.x - palm.x, p.y - palm.y), 0);

      return { pinch, handX, openScore, indexTip };
    };

    let lastSeen = performance.now();

    (async () => {
      try {
        setStatus("请求摄像头权限…请允许");
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        hands = new Hands({ locateFile: f => `https://unpkg.com/@mediapipe/hands/${f}` });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.6,
          minTrackingConfidence: 0.6,
          selfieMode: true
        });

        hands.onResults((r) => {
          const lm = r?.multiHandLandmarks?.[0];
          if (!lm) {
            drawLandmarks(null);
            if (performance.now() - lastSeen > 1200) {
              modeRef.current = MODE.FORMED;
              handYawRef.current = 0;
              pinchRef.current = 0;
              indexNDCRef.current = null;
              detailRef.current = false;
              pinchHoldStart.current = 0;
            }
            return;
          }

          lastSeen = performance.now();
          drawLandmarks(lm);

          const g = compute(lm);
          openScoreRef.current = g.openScore;

          // 平滑
          const alpha = 0.18;
          smoothHandX.current = smoothHandX.current + (g.handX - smoothHandX.current) * alpha;
          smoothPinch.current = smoothPinch.current + (g.pinch - smoothPinch.current) * alpha;

          handXRef.current = smoothHandX.current;

          // yaw
          handYawRef.current = THREE.MathUtils.clamp(smoothHandX.current * 0.75, -1.2, 1.2);

          // pinch
          pinchRef.current = smoothPinch.current;

          // ✅ hover 光标也做镜像修正（跟 handX 同一套方向）
          const ndcX = - (g.indexTip.x*2 - 1);
          const ndcY = - (g.indexTip.y*2 - 1);
          indexNDCRef.current = { x: ndcX, y: ndcY };

          // 状态机：迟滞（更稳）
          openRef.current = hysteresis(g.openScore, 0.62, 0.48, openRef.current);
          modeRef.current = openRef.current ? MODE.CHAOS : MODE.FORMED;

          // detail：阈值调低（更容易触发）
          const canDetail = (pinchRef.current > 0.70) && (hoverIndexRef.current >= 0);
          if (canDetail) {
            if (!pinchHoldStart.current) pinchHoldStart.current = performance.now();
            if (performance.now() - pinchHoldStart.current > 300) detailRef.current = true;
          } else {
            pinchHoldStart.current = 0;
            detailRef.current = false;
          }
        });

        // pump：避免 await 堆积
        const pump = () => {
          if (!hands || !video) return;
          if (video.readyState >= 2 && !inFlight) {
            inFlight = true;
            hands.send({ image: video }).catch(()=>{}).finally(()=>{ inFlight = false; });
          }
          rafId = requestAnimationFrame(pump);
        };
        rafId = requestAnimationFrame(pump);

        setStatus("摄像头已开启 ✅（开掌散 / 握拳聚 / 捏合放大拍立得 / 左右旋转树）");
      } catch(e) {
        console.error(e);
        setStatus("摄像头启动失败 ❌");
        alert(
          "摄像头无法启动。\n\n" +
          "解决：地址栏小锁 -> Camera 允许 -> 刷新（?v=数字）\n" +
          "或检查系统隐私设置。"
        );
      }
    })();

    return () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (hands && hands.close) hands.close();
      if (stream) stream.getTracks().forEach(t => t.stop());
    };
  }, [started]); // ✅ 关键：不再依赖 hover 变化

  return (
    <div className="w-full h-full relative">
      {/* UI */}
      <div className="absolute left-3 top-3 z-20 text-white bg-black/30 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl px-4 py-3 max-w-[760px]">
        <div className="font-semibold">Grand Luxury Interactive Christmas Tree（单文件·修复交互版）</div>
        <div className="text-xs opacity-85 mt-1">
          assets 自动读取拍立得；手势：开掌=CHAOS，握拳=FORMED，左右=旋转树，捏合=放大 hover 拍立得
        </div>
        <div className="flex gap-2 mt-3 flex-wrap items-center">
          <button
            className="px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15 text-sm"
            onClick={() => setStarted(true)}
            disabled={started}
          >
            ▶ 开始体验（开启摄像头）
          </button>
          <div className="text-xs opacity-80">状态：{status}</div>
        </div>

        <div className="text-xs opacity-80 mt-2">
          hoverIndex：{hoverUI} ｜ detail：{String(detailRef.current)} ｜ pinch：{pinchRef.current.toFixed(2)}
          <br/>
          openScore：{openScoreRef.current.toFixed(2)} ｜ handX：{handXRef.current.toFixed(2)} ｜ mode：{modeRef.current===MODE.CHAOS ? "CHAOS" : "FORMED"}
        </div>
      </div>

      {/* 视频面板 */}
      <div className="absolute right-3 top-3 z-20 w-[360px] rounded-2xl overflow-hidden bg-black/30 backdrop-blur-xl border border-white/10 shadow-2xl">
        <div className="flex justify-between items-center px-3 py-2 text-white/85 text-xs border-b border-white/10">
          <div>Hand Preview</div>
          <div className="font-mono opacity-80">{started ? "ON" : "OFF"}</div>
        </div>
        <div className="relative w-full aspect-video bg-black">
          <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover scale-x-[-1]" muted playsInline autoPlay></video>
          <canvas ref={canvasRef} className="absolute inset-0 w-full h-full"></canvas>
        </div>
        <div className="px-3 py-2 text-white/70 text-[11px] border-t border-white/10 whitespace-pre-line">
          {`如果这里看不到点：说明没识别到手（或权限被禁）
地址栏小锁 -> Camera Allow -> 用 ?v=3 强制刷新`}
        </div>
      </div>

      {/* 3D */}
      <Canvas
        camera={{ position:[0,4,20], fov:55 }}
        gl={{ antialias:true, alpha:false }}
        onCreated={({ gl, scene }) => {
          gl.setClearColor(new THREE.Color(COLORS.bg), 1);
          scene.fog = new THREE.Fog(COLORS.bg, 10, 46);
        }}
      >
        <ambientLight intensity={0.16} />
        <directionalLight position={[7, 12, 8]} intensity={2.35} color={"#ffd27d"} />
        <directionalLight position={[-10, 10, -12]} intensity={0.5} color={"#9bdcff"} />
        <pointLight position={[0, 4, 10]} intensity={0.25} color={"#4cffc0"} />

        <VolumetricGold />

        <Scene
          modeRef={modeRef}
          handYawRef={handYawRef}
          indexNDCRef={indexNDCRef}
          pinchRef={pinchRef}
          detailRef={detailRef}
          hoverIndexRef={hoverIndexRef}
          setHoverUI={setHoverUI}
        />

        <Environment preset="lobby" />
        <EffectComposer>
          <Bloom intensity={1.25} threshold={0.80} mipmapBlur />
        </EffectComposer>
      </Canvas>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
</script>
</body>
</html>
