<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Grand Luxury Interactive Christmas Tree (Ultra Single HTML)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#05080f; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"PingFang SC","Microsoft YaHei",sans-serif; }
    #ui{
      position:fixed; left:12px; top:12px; z-index:20;
      color:#fff; background:rgba(0,0,0,.28); backdrop-filter: blur(10px);
      padding:10px 12px; border-radius:14px; user-select:none;
      max-width:640px; line-height:1.35;
      border:1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 35px rgba(0,0,0,.40);
    }
    #ui .title{ font-size:14px; font-weight:700; letter-spacing:.2px; }
    #ui .sub{ margin-top:6px; font-size:12px; opacity:.85; }
    #ui .row{ margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #startBtn, #togglePanel{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 12px; border-radius:12px;
      font-size:13px; cursor:pointer;
    }
    #startBtn:hover, #togglePanel:hover { background:rgba(255,255,255,.12); }
    #startBtn:disabled{ opacity:.55; cursor:not-allowed; }
    #status{ margin-top:8px; font-size:12px; opacity:.88; white-space:pre-line; }

    #hint{
      position:fixed; left:12px; bottom:12px; z-index:20;
      color:rgba(255,255,255,.86);
      background:rgba(0,0,0,.26); backdrop-filter: blur(10px);
      padding:10px 12px; border-radius:14px;
      border:1px solid rgba(255,255,255,.06);
      max-width:700px; font-size:12px; white-space:pre-line;
      box-shadow: 0 10px 35px rgba(0,0,0,.40);
    }
    #err{
      position:fixed; right:12px; top:12px; z-index:30;
      display:none; max-width:620px; white-space:pre-wrap;
      color:#ffd7d7; background:rgba(80,0,0,.45);
      padding:10px 12px; border-radius:14px; font-size:12px;
      border:1px solid rgba(255,255,255,.08);
    }

    /* è§†é¢‘é¢æ¿ */
    #panel{
      position:fixed; right:12px; top:12px; z-index:25;
      width:360px;
      border-radius:16px;
      overflow:hidden;
      background:rgba(0,0,0,.30);
      backdrop-filter: blur(12px);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 35px rgba(0,0,0,.40);
      display:block;
    }
    #panelHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding:8px 10px;
      color:rgba(255,255,255,.90);
      font-size:12px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    #panelBody{ position:relative; width:100%; aspect-ratio: 16 / 9; background:#000; }
    #video{
      position:absolute; inset:0;
      width:100%; height:100%; object-fit:cover;
      transform: scaleX(-1);
      filter: contrast(1.05) saturate(1.1);
    }
    #overlayCanvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    #panelFooter{
      padding:8px 10px;
      font-size:11px;
      color:rgba(255,255,255,.72);
      border-top:1px solid rgba(255,255,255,.08);
      white-space:pre-line;
    }
    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>

  <div id="ui">
    <div class="title">Grand Luxury Interactive Christmas Treeï¼ˆå•æ–‡ä»¶Â·å…¨å¼ºåŒ–Â·æ‰‹åŠ¿ç¨³ç‰ˆï¼‰</div>
    <div class="sub">
      æ·±ç¥–æ¯ç»¿é’ˆå¶ + é‡‘è‰²é«˜å…‰ + é‡‘ç²‰é—ªçƒï¼ˆä¼ªBloomï¼šadditive+fog+shaderï¼‰
      <br/>æ‹ç«‹å¾—ç…§ç‰‡ï¼šè‡ªåŠ¨è¯»å– <code>assets/</code>ï¼ˆæ–°å¢å›¾ç‰‡æ— éœ€æ”¹ä»£ç ï¼‰
    </div>
    <div class="row">
      <button id="startBtn">â–¶ å¼€å§‹ä½“éªŒï¼ˆå¼€å¯æ‘„åƒå¤´ï¼‰</button>
      <button id="togglePanel">éšè—è§†é¢‘é¢æ¿</button>
    </div>
    <div id="status">çŠ¶æ€ï¼šæœªå¯åŠ¨ï¼ˆè±ªåç²’å­æ ‘å·²åœ¨è¿è¡Œï¼‰</div>
  </div>

  <div id="hint">
âœ… æ‰‹åŠ¿
âœ‹ å¼ å¼€æ‰‹æŒï¼šCHAOSï¼ˆæ•£å¼€æ˜Ÿäº‘ï¼‰
âœŠ æ¡æ‹³ï¼šFORMEDï¼ˆèšåˆæˆæ ‘ï¼‰
ğŸ‘‰ æ‰‹å·¦å³ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’
ğŸ¤ æ‹‡æŒ‡+é£ŸæŒ‡æåˆï¼šæ”¾å¤§å½“å‰æŒ‡å‘çš„æ‹ç«‹å¾—
ğŸ¤ æŒç»­æåˆ 300msï¼šè¯¦æƒ…æ¨¡å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œå…¶å®ƒæ·¡å‡ºï¼‰
æ— æ‰‹ï¼šè‡ªåŠ¨å›åˆ° FORMED
  </div>

  <div id="panel">
    <div id="panelHeader">
      <span>Hand Preview</span>
      <span id="panelState" style="opacity:.75; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">OFF</span>
    </div>
    <div id="panelBody">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlayCanvas"></canvas>
    </div>
    <div id="panelFooter">pinch=0.00 handX=0.00 mode=FORMED mix=0.00 | hands=0 fps=0</div>
  </div>

  <div id="err"></div>

  <!-- âœ… MediaPipe Handsï¼šåªç”¨ hands.jsï¼ˆä¸ç”¨ Camera å·¥å…·ç±»ï¼Œå…¼å®¹æ›´å¼ºï¼‰ -->
  <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

  <!-- âœ… Three.jsï¼šæ™®é€š script -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  /*********************************************************
   *  0) UI & é”™è¯¯æ˜¾ç¤º
   *********************************************************/
  const statusBox = document.getElementById("status");
  const errBox = document.getElementById("err");
  const panel = document.getElementById("panel");
  const panelState = document.getElementById("panelState");
  const panelFooter = document.getElementById("panelFooter");
  const startBtn = document.getElementById("startBtn");
  const togglePanelBtn = document.getElementById("togglePanel");
  const videoEl = document.getElementById("video");
  const overlayCanvas = document.getElementById("overlayCanvas");
  const overlayCtx = overlayCanvas.getContext("2d");

  function setStatus(s){ statusBox.textContent = "çŠ¶æ€ï¼š" + s; }
  function showError(s){ errBox.style.display = "block"; errBox.textContent = s; }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  window.addEventListener("error", (e) => showError("âŒ è¿è¡ŒæŠ¥é”™ï¼š\n" + (e?.message || e)));
  window.addEventListener("unhandledrejection", (e) => showError("âŒ Promise æŠ¥é”™ï¼š\n" + (e?.reason?.message || e?.reason || e)));

  togglePanelBtn.addEventListener("click", () => {
    const visible = panel.style.display !== "none";
    panel.style.display = visible ? "none" : "block";
    togglePanelBtn.textContent = visible ? "æ˜¾ç¤ºè§†é¢‘é¢æ¿" : "éšè—è§†é¢‘é¢æ¿";
  });

  /*********************************************************
   *  1) GitHub Pages owner/repo è‡ªåŠ¨è¯†åˆ«ï¼ˆç”¨äºåˆ— assetsï¼‰
   *********************************************************/
  function inferGithubRepo() {
    const host = location.hostname;
    const owner = host.endsWith(".github.io") ? host.replace(".github.io","") : "probiozzp";
    const seg = location.pathname.split("/").filter(Boolean);
    const repo = seg.length ? seg[0] : "christmas-tree";
    return { owner, repo };
  }

  /*********************************************************
   *  2) Three.js åœºæ™¯ï¼šå¥¢åå…‰ + èƒŒæ™¯æ˜Ÿå°˜ + ç¥–æ¯ç»¿é’ˆå¶ + æ˜Ÿé¡¶ + ä¸‰å±‚ç¯ä¸² + æ‹ç«‹å¾—
   *********************************************************/
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05080f);
  scene.fog = new THREE.Fog(0x05080f, 10, 42);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 240);
  camera.position.set(0, 4, 20);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(devicePixelRatio || 1);
  document.body.appendChild(renderer.domElement);

  // è±ªåç¯å…‰
  scene.add(new THREE.AmbientLight(0xffffff, 0.16));
  const keyLight = new THREE.DirectionalLight(0xffd27d, 2.35); keyLight.position.set(7, 12, 8); scene.add(keyLight);
  const rimLight = new THREE.DirectionalLight(0x9bdcff, 0.50); rimLight.position.set(-10, 10, -12); scene.add(rimLight);
  const fillLight = new THREE.PointLight(0x4cffc0, 0.25, 60); fillLight.position.set(0, 4, 10); scene.add(fillLight);

  // èƒŒæ™¯è¾‰å…‰ spriteï¼ˆä¼ªBloomï¼‰
  function makeGlowSpriteTexture() {
    const c = document.createElement("canvas");
    c.width = 256; c.height = 256;
    const ctx = c.getContext("2d");
    const g = ctx.createRadialGradient(128,128,0,128,128,128);
    g.addColorStop(0.0, "rgba(255,210,125,0.35)");
    g.addColorStop(0.25,"rgba(255,210,125,0.16)");
    g.addColorStop(0.55,"rgba(255,210,125,0.06)");
    g.addColorStop(1.0, "rgba(0,0,0,0)");
    ctx.fillStyle = g; ctx.fillRect(0,0,256,256);
    const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }
  const glowTex = makeGlowSpriteTexture();
  const bgGlow = new THREE.Sprite(new THREE.SpriteMaterial({
    map: glowTex, color: 0xffffff, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.85
  }));
  bgGlow.scale.set(62, 42, 1);
  bgGlow.position.set(0, 8, -40);
  scene.add(bgGlow);

  // èƒŒæ™¯æ˜Ÿå°˜
  const starCount = 1500;
  const starGeom = new THREE.BufferGeometry();
  const starPos = new Float32Array(starCount*3);
  const starSeed = new Float32Array(starCount);
  for (let i=0;i<starCount;i++){
    const x = (Math.random()*2-1) * 70;
    const y = (Math.random()*2-1) * 35 + 8;
    const z = - (10 + Math.random()*120);
    starPos.set([x,y,z], i*3);
    starSeed[i] = Math.random();
  }
  starGeom.setAttribute("position", new THREE.BufferAttribute(starPos,3));
  starGeom.setAttribute("aSeed", new THREE.BufferAttribute(starSeed,1));

  const starMat = new THREE.ShaderMaterial({
    uniforms: { uTime:{value:0} },
    vertexShader: `
      attribute float aSeed;
      uniform float uTime;
      varying float vA;
      void main(){
        vec3 p = position;
        float tw = sin(uTime*1.3 + aSeed*20.0)*0.5+0.5;
        vA = 0.10 + tw*0.22;
        vec4 mv = modelViewMatrix * vec4(p,1.0);
        gl_Position = projectionMatrix * mv;
        gl_PointSize = (1.5 + tw*1.2) * (1.0 / -mv.z) * 120.0;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying float vA;
      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);
        float a = smoothstep(0.5,0.0,d) * vA;
        gl_FragColor = vec4(vec3(1.0), a);
      }
    `,
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending
  });
  const bgStars = new THREE.Points(starGeom, starMat);
  scene.add(bgStars);

  /******** çŠ¶æ€æœº & æ§åˆ¶å‚æ•° ********/
  let mode = "FORMED";
  let targetMix = 0;
  let mix = 0;

  let targetYaw = 0;
  let yaw = 0;

  let pinch = 0;
  let hasHand = false;
  let lastHandSeenAt = 0;

  let detailMode = false;
  let pinchStartAt = 0;

  /******** è±ªåé’ˆå¶ç²’å­ ********/
  const COUNT = 7600;
  const H = 6.4;
  const R = 3.25;

  function makeConeTarget() {
    const y = Math.random() * H;
    const radius = (1 - y / H) * R;
    const a = Math.random() * Math.PI * 2;
    return [Math.cos(a)*radius, y, Math.sin(a)*radius];
  }
  function makeChaosPos() {
    const t = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const rr = 8 + Math.random() * 12;
    const x = rr * Math.sqrt(1 - u*u) * Math.cos(t);
    const y = 2 + rr * u * 0.35;
    const z = rr * Math.sqrt(1 - u*u) * Math.sin(t);
    return [x,y,z];
  }

  const foliageGeom = new THREE.BufferGeometry();
  const pos = new Float32Array(COUNT*3);
  const aTarget = new Float32Array(COUNT*3);
  const aChaos = new Float32Array(COUNT*3);
  const aSeed = new Float32Array(COUNT);
  const aSpark = new Float32Array(COUNT);

  for (let i=0;i<COUNT;i++){
    const t = makeConeTarget();
    const c = makeChaosPos();
    aTarget.set(t, i*3);
    aChaos.set(c, i*3);
    pos.set(t, i*3);
    aSeed[i] = Math.random();
    aSpark[i] = Math.random();
  }
  foliageGeom.setAttribute("position", new THREE.BufferAttribute(pos,3));
  foliageGeom.setAttribute("aTarget", new THREE.BufferAttribute(aTarget,3));
  foliageGeom.setAttribute("aChaos", new THREE.BufferAttribute(aChaos,3));
  foliageGeom.setAttribute("aSeed", new THREE.BufferAttribute(aSeed,1));
  foliageGeom.setAttribute("aSpark", new THREE.BufferAttribute(aSpark,1));

  const foliageMat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uMix: { value: 0 },
      uEmerald: { value: new THREE.Color("#0a3a2c") },
      uGold: { value: new THREE.Color("#ffd27d") },
      uWhite: { value: new THREE.Color("#ffffff") }
    },
    vertexShader: `
      attribute vec3 aTarget;
      attribute vec3 aChaos;
      attribute float aSeed;
      attribute float aSpark;

      uniform float uTime;
      uniform float uMix;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      float hash(float n){ return fract(sin(n)*43758.5453123); }

      void main(){
        vec3 p = mix(aTarget, aChaos, uMix);

        float n = hash(aSeed*17.0);
        p.y += sin(uTime*1.2 + aSeed*6.2831) * 0.03 * (0.25 + 0.75*n);
        p.x += sin(uTime*0.9 + aSeed*3.0) * 0.012;
        p.z += cos(uTime*0.9 + aSeed*3.0) * 0.012;
        p.x += sin(uTime*2.1 + aSeed*12.0) * 0.004;
        p.z += cos(uTime*2.1 + aSeed*12.0) * 0.004;

        vGlow = smoothstep(2.2, 6.5, p.y);

        float tw = sin(uTime*3.2 + aSpark*40.0) * 0.5 + 0.5;
        vSpark = smoothstep(0.82, 1.0, tw) * (0.35 + 0.65*vGlow);

        vec4 mv = modelViewMatrix * vec4(p, 1.0);
        gl_Position = projectionMatrix * mv;

        float size = mix(6.5, 15.0, vGlow);
        size += vSpark * 7.0;
        size *= (0.85 + n*0.4);

        gl_PointSize = size * (1.0 / -mv.z);
        vAlpha = clamp(1.0 - (-mv.z / 45.0), 0.20, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      uniform vec3 uEmerald;
      uniform vec3 uGold;
      uniform vec3 uWhite;

      varying float vGlow;
      varying float vAlpha;
      varying float vSpark;

      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float d = length(uv);

        float core = smoothstep(0.28, 0.0, d);
        float halo = smoothstep(0.55, 0.18, d);

        vec3 base = mix(uEmerald, uGold, vGlow*0.94);
        vec3 sparkCol = mix(uGold, uWhite, 0.65);

        vec3 col = base + sparkCol * vSpark * (0.35 + core*0.8);
        float a = halo * vAlpha;

        gl_FragColor = vec4(col, a);
      }
    `,
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending
  });

  const foliage = new THREE.Points(foliageGeom, foliageMat);
  scene.add(foliage);

  /******** æ˜Ÿé¡¶å¼ºåŒ– ********/
  function makeStarSpriteTexture() {
    const c = document.createElement("canvas");
    c.width = 256; c.height = 256;
    const ctx = c.getContext("2d");
    ctx.translate(128,128);

    const spikes = 8, outer = 92, inner = 40;
    ctx.beginPath();
    for (let i=0;i<spikes*2;i++){
      const ang = (Math.PI / spikes) * i;
      const r = (i % 2 === 0) ? outer : inner;
      ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
    }
    ctx.closePath();

    const grad = ctx.createRadialGradient(0,0,0,0,0,120);
    grad.addColorStop(0.0, "rgba(255,240,200,1.0)");
    grad.addColorStop(0.35,"rgba(255,210,125,0.9)");
    grad.addColorStop(1.0, "rgba(255,210,125,0.0)");
    ctx.fillStyle = grad;
    ctx.fill();

    const g2 = ctx.createRadialGradient(0,0,20,0,0,128);
    g2.addColorStop(0.0, "rgba(255,210,125,0.20)");
    g2.addColorStop(1.0, "rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.arc(0,0,128,0,Math.PI*2); ctx.fill();

    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }

  const starSprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: makeStarSpriteTexture(),
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    opacity:1.0
  }));
  starSprite.scale.set(3.2, 3.2, 1);
  starSprite.position.set(0, H+0.62, 0);
  scene.add(starSprite);

  const starCore = new THREE.Mesh(
    new THREE.OctahedronGeometry(0.35, 0),
    new THREE.MeshStandardMaterial({
      color:0xfff3c4, roughness:0.25, metalness:0.65,
      emissive: new THREE.Color(0xffd27d), emissiveIntensity: 0.35
    })
  );
  starCore.position.copy(starSprite.position);
  scene.add(starCore);

  const topGoldLight = new THREE.PointLight(0xffd27d, 1.4, 25);
  topGoldLight.position.copy(starSprite.position).add(new THREE.Vector3(0,0.2,0));
  scene.add(topGoldLight);

  /******** ä¸‰å±‚ç¯ä¸² ********/
  const lightGeom = new THREE.SphereGeometry(0.06, 12, 12);
  const lightMatA = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const lightMatB = new THREE.MeshBasicMaterial({ color: 0xffd27d });
  const lightMatC = new THREE.MeshBasicMaterial({ color: 0xb8fff0 });

  function makeLightStrand(count, phase, radiusBias, mat){
    const inst = new THREE.InstancedMesh(lightGeom, mat, count);
    inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    const target = [], chaos = [], seed = [];
    for (let i=0;i<count;i++){
      const y = Math.random()*H*0.95 + 0.05;
      const baseR = (1 - y/H)*R + 0.45 + radiusBias;
      const a = (y/H)*Math.PI*(9.5 + radiusBias*2.0) + phase + Math.random()*0.6;
      target.push(new THREE.Vector3(Math.cos(a)*baseR, y, Math.sin(a)*baseR));

      const c = makeChaosPos();
      chaos.push(new THREE.Vector3(c[0],c[1],c[2]));
      seed.push(Math.random());
    }
    return { inst, target, chaos, seed };
  }

  const strandA = makeLightStrand(140, 0.0, 0.00, lightMatA);
  const strandB = makeLightStrand(120, 1.8, 0.22, lightMatB);
  const strandC = makeLightStrand(100, -1.2, -0.15, lightMatC);
  scene.add(strandA.inst, strandB.inst, strandC.inst);

  const dummy = new THREE.Object3D();
  function updateStrand(strand, t, twinkleSpeed, scaleBase){
    for (let i=0;i<strand.target.length;i++){
      const p = new THREE.Vector3().lerpVectors(strand.target[i], strand.chaos[i], mix);
      const tw = (Math.sin(t*twinkleSpeed + strand.seed[i]*20)*0.5+0.5);
      p.y += Math.sin(t*1.7 + strand.seed[i]*10) * 0.05;

      dummy.position.copy(p);
      dummy.scale.setScalar(scaleBase + tw*0.55);
      dummy.updateMatrix();
      strand.inst.setMatrixAt(i, dummy.matrix);
    }
    strand.inst.instanceMatrix.needsUpdate = true;
  }

  /******** æ‹ç«‹å¾—ç…§ç‰‡ ********/
  const photoGroup = new THREE.Group();
  scene.add(photoGroup);

  const photoCards = [];
  let hoveredCard = null;
  const texLoader = new THREE.TextureLoader();

  function makePaperRoughnessTexture(){
    const c = document.createElement("canvas");
    c.width = 128; c.height = 128;
    const ctx = c.getContext("2d");
    const img = ctx.createImageData(128,128);
    for(let i=0;i<img.data.length;i+=4){
      const n = 200 + Math.floor(Math.random()*55);
      img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=255;
    }
    ctx.putImageData(img,0,0);
    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(4,4);
    return tex;
  }
  function makeRoundedAlphaTexture(radiusPx=28){
    const c = document.createElement("canvas");
    c.width = 256; c.height = 256;
    const ctx = c.getContext("2d");
    function roundRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    ctx.clearRect(0,0,256,256);
    ctx.fillStyle="rgba(255,255,255,1)";
    roundRect(18,18,220,220,radiusPx);
    ctx.fill();
    return new THREE.CanvasTexture(c);
  }

  const paperRoughTex = makePaperRoughnessTexture();
  const roundAlphaTex = makeRoundedAlphaTexture(28);

  function createPolaroidCard(texture){
    const root = new THREE.Group();
    const cardW=1.12, cardH=1.38, photoW=0.96, photoH=0.80, bottomH=0.30;

    const frameMat = new THREE.MeshStandardMaterial({
      color:"#ffffff", roughness:0.42, metalness:0.05,
      roughnessMap: paperRoughTex,
      alphaMap: roundAlphaTex,
      transparent:true, opacity:1
    });
    const frame = new THREE.Mesh(new THREE.PlaneGeometry(cardW, cardH), frameMat);
    root.add(frame);

    texture.colorSpace = THREE.SRGBColorSpace;
    const photoMat = new THREE.MeshStandardMaterial({
      map:texture, roughness:0.25, metalness:0.05, transparent:true, opacity:1
    });
    const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), photoMat);
    photo.position.set(0, 0.17, 0.002);
    root.add(photo);

    const bottomMat = new THREE.MeshStandardMaterial({
      color:"#f5f5f5", roughness:0.75, metalness:0.0,
      roughnessMap: paperRoughTex, transparent:true, opacity:1
    });
    const bottom = new THREE.Mesh(new THREE.PlaneGeometry(photoW, bottomH), bottomMat);
    bottom.position.set(0, -0.44, 0.002);
    root.add(bottom);

    const glossMat = new THREE.MeshBasicMaterial({
      color:0xffffff, transparent:true, opacity:0.0,
      blending:THREE.AdditiveBlending, depthWrite:false
    });
    const gloss = new THREE.Mesh(new THREE.PlaneGeometry(cardW, cardH), glossMat);
    gloss.position.set(0,0,0.003);
    root.add(gloss);

    const clip = new THREE.Mesh(
      new THREE.BoxGeometry(0.14, 0.11, 0.04),
      new THREE.MeshStandardMaterial({ color:"#ffd27d", roughness:0.25, metalness:0.65 })
    );
    clip.position.set(0, cardH*0.52, 0.01);
    root.add(clip);

    const string = new THREE.Mesh(
      new THREE.CylinderGeometry(0.008, 0.008, 0.7, 10),
      new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.45 })
    );
    string.position.set(0, cardH*0.52 + 0.35, 0.0);
    root.add(string);

    // hover å‘½ä¸­ä»£ç†ï¼ˆéšå½¢ï¼‰
    const hitProxy = new THREE.Mesh(
      new THREE.PlaneGeometry(1.2, 1.45),
      new THREE.MeshBasicMaterial({ transparent:true, opacity:0 })
    );
    hitProxy.position.set(0,0,0.004);
    root.add(hitProxy);

    root.userData = { frameMat, photoMat, bottomMat, glossMat };
    return root;
  }

  function placeTargetOnTree(){
    const y = Math.random()*H*0.86 + 0.55;
    const r = (1 - y/H)*R + 0.85;
    const a = Math.random()*Math.PI*2;
    return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
  }

  async function loadAssetsImagesAuto(){
    const { owner, repo } = inferGithubRepo();
    const api = `https://api.github.com/repos/${owner}/${repo}/contents/assets`;
    try{
      const res = await fetch(api, { cache:"no-store" });
      if(!res.ok){ setStatus(`assets åˆ—è¡¨è¯»å–å¤±è´¥ï¼ˆHTTP ${res.status}ï¼‰ã€‚ç¡®è®¤æ ¹ç›®å½•æœ‰ assets/`); return; }
      const items = await res.json();
      const exts = [".png",".jpg",".jpeg",".webp",".gif"];
      const files = items.filter(it => it.type==="file" && exts.some(ext => it.name.toLowerCase().endsWith(ext))).map(it => it.name);
      if(files.length===0){ setStatus("assets/ æ²¡æ‰¾åˆ°å›¾ç‰‡ï¼ˆä¸Šä¼ åˆ° assets/ï¼‰"); return; }

      setStatus(`å‘ç° assets å›¾ç‰‡ ${files.length} å¼ ï¼ŒåŠ è½½ä¸­â€¦`);
      for (const name of files){
        const url = `./assets/${encodeURIComponent(name)}`;
        texLoader.load(url, (tex)=>{
          const root = createPolaroidCard(tex);
          const target = placeTargetOnTree();
          const c = makeChaosPos();
          const chaos = new THREE.Vector3(c[0],c[1],c[2]);

          root.position.copy(target);
          root.lookAt(0, target.y, 0);
          root.rotateZ((Math.random()*2-1) * 0.28);

          photoGroup.add(root);
          photoCards.push({ id:name, root, target, chaos, seed:Math.random() });
          setStatus(`ç…§ç‰‡å·²åŠ è½½ï¼š${photoCards.length}/${files.length}ï¼ˆç‚¹å‡»å¼€å§‹ä½“éªŒå¼€å¯æ‘„åƒå¤´ï¼‰`);
        }, undefined, ()=>console.warn("å›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", url));
      }
    }catch(e){
      console.warn(e);
      setStatus("assets åˆ—è¡¨è¯»å–å¤±è´¥ï¼ˆç½‘ç»œ/æƒé™é—®é¢˜ï¼‰");
    }
  }
  loadAssetsImagesAuto();

  /******** Raycasterï¼šé£ŸæŒ‡ tip hover ********/
  const raycaster = new THREE.Raycaster();
  let lastIndexNDC = null;

  function findTopRoot(obj){
    while (obj && obj.parent && obj.parent !== photoGroup){ obj = obj.parent; }
    return obj;
  }
  function updateHover(){
    if(!lastIndexNDC || photoCards.length===0){ hoveredCard=null; return; }
    raycaster.setFromCamera(lastIndexNDC, camera);
    const hits = raycaster.intersectObjects(photoCards.map(c=>c.root), true);
    if(hits.length){
      const root = findTopRoot(hits[0].object);
      hoveredCard = photoCards.find(c=>c.root===root) || null;
    } else hoveredCard=null;
  }

  /*********************************************************
   *  3) âœ… æ‰‹åŠ¿ï¼ˆå…³é”®ä¿®å¤ï¼‰ï¼šåŸç”Ÿ getUserMedia + RAF å–‚å¸§ç»™ hands
   *********************************************************/
  let started = false;
  let hands = null;
  let stream = null;

  // ç»Ÿè®¡/è°ƒè¯•ï¼šçœ‹ onResults æ˜¯å¦åœ¨è·‘
  let handsCount = 0;
  let fps = 0;
  let lastFpsAt = performance.now();
  let frames = 0;

  function drawLandmarks(lm){
    const w = overlayCanvas.clientWidth;
    const h = overlayCanvas.clientHeight;
    const dpr = devicePixelRatio || 1;
    if (overlayCanvas.width !== Math.floor(w*dpr) || overlayCanvas.height !== Math.floor(h*dpr)){
      overlayCanvas.width = Math.floor(w*dpr);
      overlayCanvas.height = Math.floor(h*dpr);
      overlayCtx.setTransform(dpr,0,0,dpr,0,0);
    }
    overlayCtx.clearRect(0,0,w,h);
    if(!lm) return;

    overlayCtx.fillStyle = "rgba(255,210,125,0.95)";
    for (const p of lm){
      overlayCtx.beginPath();
      overlayCtx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2);
      overlayCtx.fill();
    }

    const edges = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20]
    ];
    overlayCtx.strokeStyle = "rgba(255,255,255,0.55)";
    overlayCtx.lineWidth = 2;
    for (const [a,b] of edges){
      const pa = lm[a], pb = lm[b];
      overlayCtx.beginPath();
      overlayCtx.moveTo(pa.x*w, pa.y*h);
      overlayCtx.lineTo(pb.x*w, pb.y*h);
      overlayCtx.stroke();
    }
  }

  function computeGestures(lm){
    const thumbTip = lm[4];
    const indexTip = lm[8];
    const palm = lm[0];

    const d = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
    const PINCH_MIN = 0.02, PINCH_MAX = 0.12;
    let p = (PINCH_MAX - d) / (PINCH_MAX - PINCH_MIN);
    p = clamp01(p);

    const hx = (indexTip.x - 0.5) * 2;

    const tips = [lm[8], lm[12], lm[16], lm[20]];
    const sumDist = tips.reduce((acc, pt)=> acc + Math.hypot(pt.x - palm.x, pt.y - palm.y), 0);

    return { pinch:p, handX:hx, sumDist, indexTip };
  }

  let smoothPinch = 0;
  let smoothHandX = 0;

  async function startExperience(){
    if(started) return;
    started = true;
    startBtn.disabled = true;

    setStatus("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™â€¦ï¼ˆè¯·å…è®¸ï¼‰");
    panelState.textContent = "REQ";

    try{
      // 1) æ‹‰æ‘„åƒå¤´ï¼ˆæœ€ç¨³ï¼‰
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: {ideal: 1280}, height: {ideal: 720} },
        audio: false
      });
      videoEl.srcObject = stream;

      // iOS/Safari æŸäº›æƒ…å†µå¿…é¡»æ˜¾å¼ play
      await videoEl.play();

      // 2) åˆå§‹åŒ– Hands
      hands = new Hands({
        locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: true
      });

      hands.onResults((results)=>{
        handsCount++;
        const lm = results?.multiHandLandmarks?.[0];
        if(!lm){
          hasHand = false;
          drawLandmarks(null);
          return;
        }

        hasHand = true;
        lastHandSeenAt = performance.now();
        drawLandmarks(lm);

        const g = computeGestures(lm);

        // å¹³æ»‘
        const alpha = 0.18;
        smoothPinch = smoothPinch + (g.pinch - smoothPinch) * alpha;
        smoothHandX = smoothHandX + (g.handX - smoothHandX) * alpha;
        pinch = smoothPinch;

        // é£ŸæŒ‡ tip -> NDCï¼ˆä½œä¸º raycaster å…‰æ ‡ï¼‰
        lastIndexNDC = { x: g.indexTip.x*2 - 1, y: -(g.indexTip.y*2 - 1) };

        // çŠ¶æ€æœºï¼ˆæ»å›ï¼‰
        const OPEN_T = 0.55, FIST_T = 0.38;
        if (g.sumDist > OPEN_T) { mode = "CHAOS"; targetMix = 1; }
        else if (g.sumDist < FIST_T) { mode = "FORMED"; targetMix = 0; }

        // è§†è§’æ—‹è½¬
        targetYaw = THREE.MathUtils.clamp(smoothHandX * 0.55, -0.95, 0.95);

        // è¯¦æƒ…æ¨¡å¼ï¼šå¼º pinch + hover æŒç»­ 300ms
        if (pinch > 0.8 && hoveredCard){
          if (!pinchStartAt) pinchStartAt = performance.now();
          if (performance.now() - pinchStartAt > 300) detailMode = true;
        } else {
          pinchStartAt = 0;
          detailMode = false;
        }
      });

      // 3) RAF å–‚å¸§ï¼ˆå…³é”®ä¿®å¤ç‚¹ï¼šç¡®ä¿ hands.send æŒç»­è¿è¡Œï¼‰
      async function pump(){
        if(!started || !hands) return;

        // è§†é¢‘æœªå°±ç»ªå°±ä¸å–‚ï¼Œé¿å…é™é»˜å¤±è´¥
        if (videoEl.readyState >= 2) {
          try { await hands.send({ image: videoEl }); }
          catch(e){ /* å¶å‘å¯å¿½ç•¥ï¼Œä½†ä½ è¦çœ‹å¾—åˆ°çŠ¶æ€ */ }
        }

        // fps ç»Ÿè®¡
        frames++;
        const now = performance.now();
        if (now - lastFpsAt > 500){
          fps = Math.round(frames * 1000 / (now - lastFpsAt));
          frames = 0;
          lastFpsAt = now;
        }

        requestAnimationFrame(pump);
      }
      requestAnimationFrame(pump);

      setStatus("æ‘„åƒå¤´å·²å¼€å¯ âœ…ï¼ˆå¼€å§‹æ‰‹åŠ¿äº¤äº’ï¼‰");
      panelState.textContent = "ON";

    }catch(e){
      started = false;
      startBtn.disabled = false;
      setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ âŒ");
      panelState.textContent = "ERR";
      const msg = e?.name ? `${e.name}: ${e.message}` : String(e);
      showError(
        "âŒ æ‘„åƒå¤´æ— æ³•å¯åŠ¨ã€‚\n\n" +
        "å¸¸è§åŸå› ï¼š\n" +
        "1) ä½ æ›¾ç»å¯¹è¯¥ç«™ç‚¹ç‚¹è¿‡â€œé˜»æ­¢æ‘„åƒå¤´â€ï¼ˆChrome ä»¥åä¸ä¼šå¼¹çª—ï¼‰\n" +
        "2) ç³»ç»Ÿè®¾ç½®é‡Œæœªå…è®¸æµè§ˆå™¨ä½¿ç”¨æ‘„åƒå¤´\n" +
        "3) æ‘„åƒå¤´è¢«å…¶ä»–ç¨‹åºå ç”¨\n\n" +
        "é”™è¯¯ä¿¡æ¯ï¼š\n" + msg + "\n\n" +
        "è§£å†³ï¼šç‚¹åœ°å€æ å·¦ä¾§å°é” â†’ ç½‘ç«™è®¾ç½® â†’ æ‘„åƒå¤´ â†’ å…è®¸ï¼Œç„¶ååˆ·æ–°å†ç‚¹å¼€å§‹ä½“éªŒã€‚"
      );
    }
  }
  startBtn.addEventListener("click", startExperience);

  /*********************************************************
   *  4) åŠ¨ç”»ï¼šmix/yawã€ç¯ä¸²ã€æ‹ç«‹å¾—ã€æ˜Ÿé¡¶ã€èƒŒæ™¯
   *********************************************************/
  function updatePolaroids(t){
    updateHover();

    for (const c of photoCards){
      const root = c.root;
      const mats = root.userData || {};
      const isHover = hoveredCard && hoveredCard.root === root;

      const p = new THREE.Vector3().lerpVectors(c.target, c.chaos, mix);

      const sway = Math.sin(t*0.9 + c.seed*10) * 0.10;
      const tilt = Math.cos(t*0.7 + c.seed*10) * 0.07;

      if (detailMode && isHover){
        root.position.lerp(new THREE.Vector3(0, 3.9, 6.1), 0.11);
        root.rotation.x = lerp(root.rotation.x, 0, 0.11);
        root.rotation.y = lerp(root.rotation.y, 0, 0.11);
        root.rotation.z = lerp(root.rotation.z, 0, 0.11);
      } else {
        root.position.lerp(p, 0.22);
        root.lookAt(0, root.position.y, 0);
        root.rotateZ(sway * 0.6);
        root.rotation.x += tilt*0.05;
        root.rotation.y += sway*0.03;
      }

      // pinch æ”¾å¤§ hover å¡ç‰‡
      const targetScale = isHover ? (1 + pinch*1.6) : 1;
      root.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.18);

      // åå…‰æ¡å¸¦
      if (mats.glossMat){
        const gl = (Math.sin(t*1.7 + c.seed*10)*0.5+0.5);
        mats.glossMat.opacity = lerp(mats.glossMat.opacity, (isHover?0.22:0.08)*gl, 0.12);
      }

      // è¯¦æƒ…æ¨¡å¼æ·¡å‡ºå…¶ä»–
      const targetOpacity = (detailMode && !isHover) ? 0.18 : 1.0;
      if (mats.frameMat) mats.frameMat.opacity = lerp(mats.frameMat.opacity, targetOpacity, 0.12);
      if (mats.photoMat) mats.photoMat.opacity = lerp(mats.photoMat.opacity, targetOpacity, 0.12);
      if (mats.bottomMat) mats.bottomMat.opacity = lerp(mats.bottomMat.opacity, targetOpacity, 0.12);
    }
  }

  function animate(){
    requestAnimationFrame(animate);
    const t = performance.now()*0.001;

    // æ— æ‰‹å›é€€
    if (started && hasHand && (performance.now() - lastHandSeenAt > 1200)){
      hasHand = false;
      pinch = 0;
      lastIndexNDC = null;
      detailMode = false;
      mode = "FORMED"; targetMix = 0;
      targetYaw = 0;
      panelState.textContent = "ON";
    }

    // mix å¹³æ»‘
    const speed = 2.2;
    const a = 1 - Math.exp(-speed * 0.016);
    mix = mix + (targetMix - mix) * a;

    // yaw å¹³æ»‘
    yaw = yaw + (targetYaw - yaw) * 0.10;

    // ç›¸æœºæ¼‚æµ®
    const camY = 4 + Math.sin(t*0.6)*0.15;
    camera.position.lerp(new THREE.Vector3(0, camY, 20), 0.08);
    camera.rotation.y = yaw;
    camera.lookAt(0, 4, 0);

    // èƒŒæ™¯æ˜Ÿå°˜
    starMat.uniforms.uTime.value = t;

    // æ ‘è‡ªè½¬
    foliage.rotation.y += 0.0022;
    photoGroup.rotation.y = foliage.rotation.y;
    strandA.inst.rotation.y = foliage.rotation.y;
    strandB.inst.rotation.y = foliage.rotation.y;
    strandC.inst.rotation.y = foliage.rotation.y;

    // ç²’å­ shader
    foliageMat.uniforms.uTime.value = t;
    foliageMat.uniforms.uMix.value = mix;

    // æ˜Ÿé¡¶
    const sp = 1 + Math.sin(t*2.1)*0.08;
    starSprite.scale.set(3.2*sp, 3.2*sp, 1);
    starCore.rotation.y += 0.01;
    starCore.rotation.x += 0.006;
    topGoldLight.intensity = 1.15 + (Math.sin(t*2.4)*0.5+0.5)*0.45;

    // ç¯ä¸²
    updateStrand(strandA, t, 3.1, 0.85);
    updateStrand(strandB, t, 2.4, 0.90);
    updateStrand(strandC, t, 3.7, 0.80);

    const tw = (Math.sin(t*1.6)*0.5+0.5);
    lightMatA.color.setHSL(0.14, 0.20, 0.90 + tw*0.05);
    lightMatB.color.setHSL(0.12, 0.35, 0.80 + tw*0.08);
    lightMatC.color.setHSL(0.47, 0.25, 0.84 + tw*0.06);

    // æ‹ç«‹å¾—
    updatePolaroids(t);

    // é¢æ¿çŠ¶æ€
    panelFooter.textContent =
      `pinch=${pinch.toFixed(2)} handX=${(targetYaw/0.55).toFixed(2)} mode=${mode} mix=${mix.toFixed(2)} | hands=${handsCount} fps=${fps}` +
      (detailMode ? "  DETAIL" : "") +
      (hasHand ? "  HANDâœ…" : "  HANDâ€”");

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  </script>
</body>
</html>
