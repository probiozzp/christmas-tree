<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>3D æ‰‹åŠ¿æ§åˆ¶ç²’å­åœ£è¯æ ‘</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #05080f;
      font-family: sans-serif;
    }
    #upload {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      color: white;
    }
    #upload input {
      margin-top: 4px;
    }
  </style>
</head>
<body>

<div id="upload">
  ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ï¼ˆä½œä¸ºæ ‘ä¸Šè£…é¥°ï¼‰
  <br />
  <input type="file" id="fileInput" multiple accept="image/*" />
</div>

<video id="video" style="display:none;"></video>

<script type="module">
/* ======================================================
 *  ä¾èµ–å¼•å…¥
 * ====================================================== */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { Hands } from "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

/* ======================================================
 *  å…¨å±€å‚æ•°ï¼ˆå¯è°ƒï¼‰
 * ====================================================== */
const PARAMS = {
  TREE_HEIGHT: 6,
  TREE_RADIUS: 3,
  PARTICLE_COUNT: 4000,
  PINCH_MIN: 0.02,
  PINCH_MAX: 0.12,
  DETAIL_HOLD_MS: 300
};

/* ======================================================
 *  Three.js åŸºç¡€åœºæ™¯
 * ====================================================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x05080f, 8, 20);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.set(0, 3, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ======================================================
 *  ç²’å­åœ£è¯æ ‘ç³»ç»Ÿ
 * ====================================================== */
const positions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);
const basePositions = new Float32Array(PARAMS.PARTICLE_COUNT * 3);

for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
  const y = Math.random() * PARAMS.TREE_HEIGHT;
  const radius = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS;
  const angle = Math.random() * Math.PI * 2;

  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  positions.set([x, y, z], i * 3);
  basePositions.set([x, y, z], i * 3);
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
  size: 0.06,
  transparent: true,
  opacity: 0.9,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  color: new THREE.Color("#ffd27d")
});

const treePoints = new THREE.Points(geometry, material);
scene.add(treePoints);

/* æ˜Ÿæ˜Ÿ */
const star = new THREE.Mesh(
  new THREE.SphereGeometry(0.25, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xffffcc })
);
star.position.y = PARAMS.TREE_HEIGHT + 0.3;
scene.add(star);

/* ======================================================
 *  ç…§ç‰‡ç³»ç»Ÿ
 * ====================================================== */
const photoGroup = new THREE.Group();
scene.add(photoGroup);
const photoMeshes = [];

document.getElementById("fileInput").addEventListener("change", (e) => {
  [...e.target.files].forEach(file => {
    const url = URL.createObjectURL(file);
    const texture = new THREE.TextureLoader().load(url);
    const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
    const geo = new THREE.PlaneGeometry(1, 1);
    const mesh = new THREE.Mesh(geo, mat);

    const y = Math.random() * PARAMS.TREE_HEIGHT * 0.8 + 0.5;
    const r = (1 - y / PARAMS.TREE_HEIGHT) * PARAMS.TREE_RADIUS + 0.5;
    const a = Math.random() * Math.PI * 2;
    mesh.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
    mesh.lookAt(0, y, 0);

    photoGroup.add(mesh);
    photoMeshes.push(mesh);
  });
});

/* ======================================================
 *  Raycasterï¼ˆé£ŸæŒ‡é€‰ä¸­ï¼‰
 * ====================================================== */
const raycaster = new THREE.Raycaster();
let hoveredPhoto = null;

/* ======================================================
 *  MediaPipe Hands
 * ====================================================== */
let lastPinchTime = 0;
let detailMode = false;
let pinchStrength = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(results => {
  if (!results.multiHandLandmarks?.length) {
    pinchStrength = 0;
    return;
  }

  const lm = results.multiHandLandmarks[0];
  const index = lm[8];
  const thumb = lm[4];

  /* pinch */
  const d = Math.hypot(index.x - thumb.x, index.y - thumb.y);
  pinchStrength = THREE.MathUtils.clamp(
    (PARAMS.PINCH_MAX - d) / (PARAMS.PINCH_MAX - PARAMS.PINCH_MIN),
    0,
    1
  );

  /* Raycaster */
  const ndc = {
    x: index.x * 2 - 1,
    y: -(index.y * 2 - 1)
  };
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(photoMeshes);

  hoveredPhoto = hits[0]?.object || null;

  if (pinchStrength > 0.8) {
    if (!lastPinchTime) lastPinchTime = performance.now();
    if (performance.now() - lastPinchTime > PARAMS.DETAIL_HOLD_MS) {
      detailMode = true;
    }
  } else {
    lastPinchTime = 0;
    detailMode = false;
  }
});

const cameraMP = new Camera(document.getElementById("video"), {
  onFrame: async () => await hands.send({ image: document.getElementById("video") }),
  width: 640,
  height: 480
});
cameraMP.start();

/* ======================================================
 *  åŠ¨ç”»å¾ªç¯
 * ====================================================== */
function animate() {
  requestAnimationFrame(animate);

  /* ç²’å­å‘¼å¸ */
  const pos = geometry.attributes.position.array;
  for (let i = 0; i < PARAMS.PARTICLE_COUNT; i++) {
    pos[i * 3 + 1] =
      basePositions[i * 3 + 1] +
      Math.sin(Date.now() * 0.001 + i) * 0.02;
  }
  geometry.attributes.position.needsUpdate = true;

  /* ç…§ç‰‡ hover + pinch ç¼©æ”¾ */
  photoMeshes.forEach(m => {
    m.scale.lerp(
      hoveredPhoto === m
        ? new THREE.Vector3(1 + pinchStrength * 1.5, 1 + pinchStrength * 1.5, 1)
        : new THREE.Vector3(1, 1, 1),
      0.15
    );
    m.material.opacity = detailMode && hoveredPhoto !== m ? 0.2 : 1;
  });

  if (detailMode && hoveredPhoto) {
    hoveredPhoto.position.lerp(
      new THREE.Vector3(0, PARAMS.TREE_HEIGHT / 2, 2),
      0.08
    );
  }

  treePoints.rotation.y += 0.002;
  renderer.render(scene, camera);
}

animate();

/* ======================================================
 *  resize
 * ====================================================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>